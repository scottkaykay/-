## TCP连接的建立

TCP头部包含：

· 序列号：建立连接时由计算机生成的**随机数**作为其初始值，通过SYN包传送给接收端主机。每发送一次数据就累加一次数据字节数的大小，用来解决**网络包乱序问题**\
· 确认应答号：下一次期望收到的序列号。发送端收到这个确认应答后可认为这个序号前面的数据都已经收到，用来解决丢包问题。\
· 控制位：ACK,RST,SYN,FIN

ACK除了最初建立连接时的SYN包之外，都必须设置为1\
RST=1 表示出现异常必须断开TCP连接\
SYN=1表示希望建立连接，并设置其序列号初始值\
FIN=1表示后面不会再有数据发送，希望断开连接。

### 1.什么是TCP

传输控制协议，它是工作在运输层上的可靠数据传输服务，能确保接收端的网络包无损坏，无间隔，无冗余，按序。是面向连接的，可靠的，基于字节流的传输层通信协议。

· 面向连接：指一对一的连接\
· 可靠的：无论网络链路中发生什么样的变化，TCP都可保证一个报文一定能够到达接收端\
· 字节流：消息间没有边界，但消息是有序的，当前一个消息没有收到的时候，即使收到了后面的字节，也不能扔给应用层。同时应丢弃重复的报文，

### 2.TCP连接

一个四元组可确定一个TCP连接：源地址，源端口，目的地址，目的端口

源地址，目的地址在(32bit)IP头部中，源端口，目的端口(16bit)在TCP头部中，指明报文应该发送给哪个进程。

**最大TCP连接数=客户端的IP数*客户端的端口数**

服务器端最大并发数远不能达到上面计算的上限：\
· 文件描述符限制。每个socket都是 文件，都要通过ulimit配置文件描述符数目;\
· 内存限制，每个TCP连接都要占用一定内存，操作系统的内存空间是有限的。

### 3. TCP和UDP的区别

i.连接

· TCP是面向连接的，可靠的数据传输协议，传输前必须先建立连接\
· UDP不需要建立连接，可直接发送数据

ii.服务对象

· TCP是一对一的两点服务，即一条连接只有两个端点\
· UDP支持一对一，一朵朵，多对多的交互通信

iii. 可靠性

· TCP是可靠交付数据的，数据可以无差错，不丢失，不重复，按序到达\
· UDP是尽最大努力交付，不保证可靠交付。

iv.拥塞控制，流量控制

· TCP有拥塞控制和流量控制机制，保证数据传输的安全性\
· UDP没有这样的机制，即使网络拥塞严重，也不影响其发送速率

v.首部开销

· TCP首部长度较长，不使用选项字段为20字节，开销比较大\
· UDP首部只有8个字节，固定不变，开销较小

vi.传输方式

· TCP是流式传输，信息没有边界，但保证顺序和可靠\
· UDP是一个包一个包地发送，是有边界的，但可能会丢包和乱序。

vii. 分片不同

· TCP的数据大小如果大于MSS（网络传输数据最大长度，最大分段大小，加上头部就成了MTU）大小，会在**传输层进行分片**，目标主机收到后，也会在传输层进行重组，如果中途丢失了一个分片，只要重传这个分片\
· UDP的数据大小如果大于MTU（网络最大传输单元），会在**网络层进行分片**，目标主机收到后，在网络层组装完数据，再传给运输层，如果中途丢了一个分片，需要重传所有的数据包，所以传输效率非常低。

viii.应用场景

TCP常用于可靠数据传输： FTP文件传输，HTTP/HTTPS

UDP是无连接的，可随时发送数据，经常用于：

· 包总量较少的通信\
· 音视频等多媒体通信\
· 广播通信

### 4.UDP,TCP首部字段的不同

UDP头部没有首部长度字段，因为UDP首部长度是固定的，而TCP有可变长的选项字段，需要记录首部长度。

TCP数据长度=IP总长-IP首部长度-TCP首部长度

UDP的包长度字段可能是为了使得UDP的首部长度达到4字节的整数倍才添加的

### 5. TCP连接建立

#### 三次握手

i. 一开始，客户端和服务器端的状态均为CLOSED。服务端监听某个端口，处于LISTEN状态。\
ii. 客户端随机初始化序列号(client_isn),把此序号放在TCP首部中的序号字段中，同时把SYN标志位置为1，表示SYN报文。接着发送第一个SYN报文给服务器，该报文不含应用层数据，发送完后客户端进入SYN_SENT状态\
iii. 服务器端收到客户端的SYN报文后，先随机初始化自己的序号(server_isn)，将此序号放进TCP首部中的序号字段，再把TCP首部的确认应答号填入(client_isn+1),把SYN和ACK位置1.
最后把该报文发送给客户端，也不含应用层数据，之后服务端处于SYN_RCVD状态\
iv.客户端收到服务端报文后，还需要向服务端回应一个应答报文，将ACK标志位置1，在确认应答号填入(server_isn+1),再把该报文发送给服务端，之后进入ESTABLISHED状态。\
v. 服务端收到客户端的应答报文后，也进入ESTABLISHED状态。

第三次握手是可以携带数据的，前两次握手是不可以携带数据的。

Linux查看TCP连接状态：netstat -napt

#### 为什么是三次握手

简单来说：要确认双方的收发能力都是正常的

主要原因：

i. 防止旧的重复连接初始化造成混乱。如果客户端连续发送多次SYN报文，网络拥堵的情况下：\
· 一个旧的SYN报文比最新的SYN报文先到达服务端;\
· 服务端返回SYN+ACK报文给客户端\
· 客户端接收报文，可根据上下文信息判断这是个历史连接（序列号过期或超时），客户端就会发送RST报文给服务端中止连接。如果不是历史连接，客户端返回的就是ACK报文了。

ii.同步双方的序列号

序列号在TCP连接中拥有重要的作用：\
接收方可去除重复的数据\
接收方可根据数据报的序列号按序接收数据\
可以标识发送出去的数据中哪些是被接收方接收到了的

客户端发送携带初始序列号的SYN报文，服务端接收到后返回SYN+ACK，表示收到了客户端的序列号，客户端需要做出回应，发送ACK应答报文给服务端，表示收到了服务端的序列号。

iii.避免资源浪费

如果只有两次握手，SYN报文在网络中阻塞，客户端没有收到服务端的ACK，会超时重传SYN，两次握手的情况下，服务端一旦收到SYN报文，就会先建立一个连接，后面的SYN报文到达时，服务端就会建立很多冗余的连接，浪费资源。

#### 为什么客户端和服务端的初始序列号不相同

· 使通信双方**根据序列号将不属于本连接的报文段丢弃**。\
· 为了安全性考虑，防止黑客伪造的相同序列号的TCP报文被对方接收。

#### 初始序列号ISN是如何随机产生的

起始序列号是基于时钟的，每4ms 加1  ISN=M+F,  M为计时器，F是一个Hash算法（MD5算法比较好）

#### 既然IP层会分片，TCP层为什么还要MSS？

· MTU:一个网络包的最大长度（包含IP头部，TCP头部，数据），以太网中一般为1500字节\
· MSS:除去IP头部和TCP头部后，一个网络包所能容纳的TCP数据的最大长度

如果TCP整个报文交给IP层分片，出现分片丢失则会大大降低效率：\
IP层有一个超过MTU大小的数据要发送时，IP层就会对其分片，把数据分片成若干片，保证每一个分片都小于MTU，传送到目标主机后，由目标主机的IP层进行组装，再向上传递给运输层。
如果发现有分片丢失，则不会响应ACK给发送方。利用超时重传机制，发送方重新发送整个TCP报文，效率很低。

为了达到最佳的传输性能，TCP协议在建立连接时需要事先商定MSS值，如果发现数据大小超过MSS，在运输层就对其分片，形成的IP包也不会超过MTU,如果最后分片丢失，只需要重传对应的分片，大大提高传输效率。

#### SYN攻击

短时间内，攻击者伪造不同IP地址的SYN报文，发送给服务端，服务端每接收一个SYN报文，就回应SYN+ACK，但又得不到未知主机的回应，久而久之就会占满服务端的SYN接收队列，导致无法响应正常用户的需求。

解决方案是SYN cookie,服务器端收到SYN报文时先不分配资源，SYN cookie是一个利用SYN报文源地址，目的地址，端口号，一个只有服务器知道的秘密数进行散列得到的值，将该值作为SYN+ACK报文的序列号发送给客户端，如果它是个合法的客户，
会回应ACK报文，利用该报文的源地址，目的地址，端口号和秘密数进行散列，如果得到的数+1等于确认号，则认为该客户是合法的，再生成一个全开的连接。

### 6.TCP连接断开

#### 四次挥手

双方都可以主动断开连接，断开连接后主机中的资源将被释放。

· 客户端打算关闭连接，发送一个FIN被置为1的报文，进入FIN_WAIT1状态\
· 服务端接收到该报文后，就向客户端发送ACK应答报文，进入CLOSE_WAIT状态\
· 客户端收到服务端的ACK应答报文后，进入FIN_WAIT2状态\
· 等待服务端处理完数据后，也向客户端发送FIN报文，之后服务端进入LAST_ACK状态\
· 客户端接收到服务端的FIN报文后，回应ACK报文，进入TIME_WAIT状态，等待2个MSL后，关闭连接，进入CLOSED
· 服务端接收到客户端的ACK报文后自动进入CLOSED状态

注意，**主动关闭连接的才有TIME_WAIT状态**

#### 为什么挥手4次

一方发送FIN，只说明这一方已经没有数据再发送了，但对端可能还有数据需要发送，对端在收到FIN时，回应一个ACK。对端也没有数据发送时，再发送FIN给当前端，表示可以关闭连接。这个过程时独立的，各自分开，所以需要四次。

#### 为什么TIME_WAIT等待的时间是2MSL?

MSL:报文最大生存时间，是任何报文在网络中存在的最长时间，超过这个时间报文会被丢弃。

· 可靠中止TCP连接，服务端没有收到客户端的ACK回应，会超时重传FIN报文，此时客户端不能关闭了，否则会出错；\
· 保证迟来的报文段有时间处理。在收到服务端的FIN报文后，客户端依然可能收到来自服务端的迷途报文，如果此时有新连接使用了相同的IP地址和端口号，就会出现数据混乱。所以2MSL可以保证这些报文彻底消失，避免给新连接带来麻烦。

#### TIME_WAIT过多有什么危害？

· 内存资源占用\
· 端口资源占用，一个TCP连接至少占用一个本地端口，如果端口资源资源被耗尽，则无法建立新连接

客户端主要是端口资源，服务端主要是系统资源

### 4. socket编程

· 客户端和服务端初始化socket,得到文件描述符\
· 服务端调用bind绑定IP地址和端口\
· 服务端调用listen监听端口\
· 服务端调用accept等待客户连接\
· 客户端调用connect，向服务器地址和端口发起连接请求\
· 服务端调用accept返回用于传输的socket文件描述符，这个socket是已完成连接的socket\
· 客户端调用write写入数据，服务端调用read读取数据\
· 客户端断开连接时调用close，服务端read读取数据就会读取到EOF,待数据处理完毕，服务端调用close关闭连接。

监听socket和已完成连接的socket是两个不同的socket。

#### listen中backlog参数的意义

Linux内核会维护两个队列：\
· 未完成连接的队列（SYN队列）：接收到SYN报文，进入SYN_RCVD状态\
· 已完成连接的队列（Accept队列）：已完成三次握手的过程，处于ESTABLISHED状态

Linux2.2之前，backlog是未完成连接队列的长度，2.2以后是已完成连接队列的长度。\
客户端connect成功返回是在第二次握手（收到服务端的SYN+ACK），服务端accept成功返回是在第三次握手。\
客户端调用close，会进入四次挥手过程。
