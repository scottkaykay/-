## 银行家算法

当一个进程申请使用资源的时候，银行家算法通过先试探分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。

![]()

· 包含进程Pi的需求资源数量（也是最大需求资源数量，MAX）\
· 已分配给该进程的资源A(Allocation)\
· 还需要的资源数量N(Need=M-A)

Available为空闲资源数量，即资源池（资源池的剩余资源数量+已分配给所有进程的资源数量=系统中的资源总量）

假设进程P1申请资源，银行家算法先试探性地分配给它资源（当然要保证当前资源池的资源数量是足够的），如果申请的资源数量小于等于Available，接着判断分配给P1后剩余的资源，
能不能使进程队列的某个进程执行完毕。若没有进程可以执行完毕，则系统处于不安全状态(此时没有一个进程能够完成并释放资源，随时间推移，系统终将处于死锁状态)。
如果有进程可执行完毕，则假设**回收已分配给它的资源（剩余资源数量增加），把这个进程标记为已完成，并继续判断队列中的其他进程，如果所有进程都可以执行完毕，则系统处于安全状态，并根据可完成进程的分配
顺序生成安全序列**:\
Process   Allocation   Need   Available

 P0       0 0 3 2     0 0 1 2  1 6 2 2
 
 P1       1 0 0 0     1 7 5 0
 
 P2       1 3 5 4     2 3 5 6 
 
 P3       0 3 3 2     0 6 5 2
 
 P4       0 0 1 4     0 6 5 6
 
 分析：状态是否安全？ 如果进程P2提出请求request(1,2,2,2)后系统能否将资源分配给它
 
 Process   Work        Need      Allocation    Work+Allocation   Finish

 P0       1 6 2 2     0 0 1 2     0 0 3 2         1 6 5 4         true
 
 P3       1 6 5 4     0 6 5 2     0 3 3 2         1 9 8 6         true
 
 P4       1 9 8 6     0 6 5 6     0 0 1 4         1 9 9 10        true 
 
 P1       1 9 9 10    1 7 5 0     1 0 0 0         2 9 9 10        true
 
 P2       2 9 9 10    2 3 5 6     1 3 5 4         3 12 14 14      true
 
 所以是状态安全的
 
 P2发出请求向量Request(1,2,2,2):\
 · Request2(1,2,2,2)<= Need(2,3,5,6)\
 · Request2(1,2,2,2)<= Acailable(1,6,2,2)\
 · 系统先试探性地给P2分配资源，并修改Available, Allocation2 ,Need2:\
 Available=(0,4,0,0)  Allocation2=(1,3,5,4)+(1,2,2,2)=(2,5,7,6)  Need2=(2,3,5,6)-(1,2,2,2)=(1,1,3,4)
 
 · 此时再进行安全性检查，发现Available=(0,4,0,0)不能满足任何一个进程，所以判定系统不能进入安全状态，不能分配给P2相应的资源。
