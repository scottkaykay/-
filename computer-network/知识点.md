## TCP粘包问题

socket网络编程为端到端通信，由客户端端口，服务端端口，客户端IP,服务端IP+协议能唯一表示一个连接。发送端为了将多个发往接收端的包更加高效地发给接收端，采用了Nagle优化算法,
将多次间隔较小，数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。如此，接收端就必须用科学的拆包机制来分辨这些数据。

TCP粘包就是发送方发送的若干包数据到达接收方时粘成了一个包，后一个包数据的头紧接着前一包的数据尾。

### 原因

发送方原因： TCP默认使用Nagle算法（减少网络中报文段的数量），Nagle算法主要做两件事：\
· 只有上一个分组得到确认，才会发送下一个分组\
· 收集多个小分组，在一个确认到来时一起发送

接收方原因：接收端接收到数据包的时候并不会马上交到应用层进行处理，或者是应用层不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。
如果TCP接收数据包的速度大于应用程序从缓存中读取数据的速度，多个包就会被缓存，应用程序可能读取到多个首尾相接黏到一起的包。

### 什么时候需要处理粘包问题

发送方发送的多组数据本来就是同一块数据的不同部分，此时不需要处理粘包；如果多个分组毫不相干，甚至是并列关系，这个时候就一定要处理粘包现象了

### 处理方法

对发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法

接收方没有办法处理粘包问题，只能交给应用层处理：应用程序从接收缓存中读取分组时，读完一条数据，就循环读取下一条数据，如何判断数据长度？\
· 格式化数据：每条数据有固定的格式（开始符结束符），要确保数据内部没有开始符和结束符。\
· 发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度。

UDP没有粘包问题UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。

## TIME_WAIT 状态过多原因，如何解决

高并发短连接的TCP服务器上，当服务器处理完请求后，立刻主动正常关闭连接，这就会产生大量处于TIME_WAIT状态的socket。如果客户端的并发量持续很高，TCP/IP连接断开后，端口会在短时间内保持TIME_WAIT的状态几分钟，也就意味着在短时间范围内同时占用大量的端口，端口占用数越多可能导致端口不够用，进而拒绝部分客户的服务。

解决：修改tcp/ip内核参数，/etc/sysctl.conf  加入以下内容

net.ipv4.tcp_syncookies=1  开启SYN cookies,可防范少量SYN攻击，默认为0，表示关闭\
net.ipv4.tcp_tw_reuse=1  表示开启重用，允许将TIME_WAIT sockets重新用于新的TCP连接，默认为0，表示关闭\
net.ipv4_tcp_tw_recycle=1  表示开启TCP连接中TIME_WAIT sockets的快速回收，默认为0，表示关闭\
net.ipv4_tcp_fin_timeout 修改默认的TIMEOUT时间

执行 /sbin/sysctl -p 让参数生效

