## HTTP基础

### 1.HTTP的概念

即超文本传输协议。它是一个专门在**两点**传输文字，图片，音频，视频等超文本数据的约定和规范。

五大类状态码：

·1xx: 提示信息。表示目前是协议处理的中间状态，还需要后续的操作。\
·2xx: 成功。报文已经受到并正确处理。200  204  206\
·3xx: 重定向，资源位置发生变化，需要客户端重新发送请求。 301  302  304\
·4xx: 客户端错误。请求报文有误，服务端无法处理  400 403  404(NOT FOUND)\
400 Bad Request:客户端请求报文有错误，但只是个笼统的错误。\
403 Forbidden:服务器禁止访问资源，并不是客户端的请求出错。\
404 Not Found:请求的资源在服务器上不存在或未找到，故无法提供给客户端。\
·5xx: 服务端错误。服务器处理请求时内部发生错误。 500  501  502  503
502 Bad Gateway: 服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。\
503 Service Unavailable: 表示服务器当前很忙，暂时无法响应请求。

### 2.HTTP常见字段

i. Host字段

客户端发送请求时，用来指定服务器的域名。有了Host字段就可以将请求发往同一台服务器中的不同网站。

ii. Content-Length字段

服务器返回数据时，会有Content-Length字段，表示本次回应的数据长度。

iii. Connection字段

Connection字段常用于**客户端要求与服务端使用TCP持久连接**，以便其他请求复用。

HTTP1.1版本默认连接都是持久连接，但为了兼容老版本的HTTP,需要指定Connection首部字段的值为Keep-Alive

iv. Content-Type字段

服务器回应客户端，本次的数据格式。客户端在发送请求时，可在accept字段中说明自己接受什么格式的数据。

v. Content-Encoding字段

说明数据压缩采用的方法。表示服务器返回的数据使用了什么压缩格式。客户端在请求时，可在Accept-Encoding字段说明自己可接受哪些压缩方法。

### 3.GET与POST

GET: 请求从服务器获取资源，这个资源可以是文本，图片，视频等。\
POST：它向URI指定的资源提交数据，数据就放在报文的body里。比如，评论时的留言，点击提交后，留言信息会放进报文的body里，拼接好POST请求头，通过TCP协议发送给服务器。

GET是安全幂等的，POST不是安全幂等的。（安全：不会破坏服务器上的数据，幂等：多次操作的结果都是相同的）

### 4.HTTP特性

i. 简单

基本的报文格式：header+body, header是简单的key-value形式，易于理解。

ii. 灵活，易于扩展

HTTP协议中的各类请求方法，URL/URI, 状态码，头字段等各个组成要求都没有固定死，允许开发人员自定义和扩充。

iii. 应用广泛和跨平台

从PC的浏览器，到手机应用，都可以运用HTTP

缺点： 无状态，明文传输

无状态：

好处：服务器不用去记忆HTTP的状态，所以不需要额外的资源来记录状态信息，可以减轻服务器的负担，把更多的CPU和内存用来提供对外服务。\
坏处：没有记忆能力，在完成关联性操作时会非常麻烦。

解决无状态的问题，可以使用cookie。cookie通过在请求和响应报文中写入cookie信息来控制客户端的状态。即客户端第一次请求后，服务器会生产cookie，添加在
响应报文中，客户端接收并保存，下一次请求中包含cookie信息，服务器便能识别。

明文传输：

好处：方便阅读，便于调试\
坏处：没有加密，容易泄露

iv 不安全

· 通信使用明文，内容可能被窃听，容易丢失账号密码信息。\
· 不验证通信方的身份，可能遭遇伪装，访问到假的网站。\
· 无法证明报文的完整性，所以信息可能会遭到篡改。

为解决安全性问题，可使用HTTPS,即运行在SSL/TLS上的HTTP协议。

### 5.HTTP1.1特性

i. 支持长连接。早期的HTTP1.0只支持短连接，即每发起一个请求都要新建一次TCP连接，而且是串行请求，不断地握手挥手，增加了通信开销。长连接减少了TCP连接
的重复建立和断开造成的额外开销，减轻了服务器负载。长连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。

ii.管道网络传输。由于使用长连接，管道网络传输成为可能个，即在一个TCP连接中，客户端可以发起多个请求，只要第一个请求发送出去了，不必等其回来，就可发送第二个请求出去，
可减少整体的响应时间，但服务器必须按照请求的先后顺序将响应返回给客户端，因为其没有序列号确认号机制。如果前面的回应特别慢，后面的请求就需要排队，造成队头阻塞。

iii. 队头阻塞

顺序发送的请求序列中有一个请求因为某种原因被阻塞时，后面的请求也一并被阻塞了，导致客户端一直请求不到数据。

### 6. HTTP与HTTPS

HTTP与HTTPS的区别：

· HTTP为超文本传输协议，信息传输形式是明文传输，容易泄露信息。HTTPS是运行在SSL/TLS上的HTTP，信息传输采用加密形式。\
· HTTP的连接建立更简单，只需要TCP三次握手便可，HTTPS还需要进行SSL/TLS握手。才可进行加密报文传输。\
· HTTP的端口号为80，HTTPS的端口号为443.
` HTTPS协议需要向CA申请数字证书，保证服务器的身份是可信的。

HTTPS解决的问题：信息加密，防止篡改，验证服务端的真伪

### 7.SSL/TLS握手

i. ClientHello

客户端向服务器发起加密通信请求，即ClientHello请求。这一步客户端主要发送：\
1.客户端支持的SSL/TLS协议版本\
2.客户端生产的随机数，后续用于生产会话秘钥\
3.客户端支持的密码套件，如RSA加密算法

ii. SeverHello

服务器收到客户端请求后，向客户端返回请求，包含如下内容：\
1.确认SSL/TLS版本，如果浏览器不支持，则关闭加密通信\
2.服务器产生随机数，后续用于生产会话秘钥\
3.确认密码套件列表\
4.服务器的数字证书

iii. 客户端回应

客户端收到服务器的响应后，第一要务是验证证书的真实性。通过使用对应机构的公钥解密，与自己生成的证书签名比较，如果一致则为可信的证书。再次解密得到
服务器的公钥，加密自己的报文，向服务器发送信息：

1. 一个随机数，该随机数会被服务器公钥加密\
2.加密通信算法改变通知，表示随后的信息都将用会话秘钥加密通信\
3.客户端握手结束通知，表示客户端握手阶段已经结束。这一项同时把之前的所有内容的发生的数据做个摘要，用来供服务端校验。

上面第一项的随机数是整个握手阶段生成的第三个随机数，这样服务器和客户端就同时有三个随机数。接着就用双方协商的加密算法，**各自生成**本次通信的会话秘钥。

iv.服务器最后回应

服务器收到客户端的第三个随机数后，通过协商的加密算法，计算出本次通信的会话秘钥，向客户端发送信息：

1.加密通信算法改变通知，表示随后的信息都会用会话秘钥加密通信\
2.服务器握手结束通知，表示服务器端握手结束。这一项同时把之前所有内容的发生的数据做个摘要，供客户端校验。

### 8. HTTP版本的演变

i. HTTP1.1比HTTP1.0的改进

· 支持TCP长连接，减少了TCP连接反复建立和释放造成的开销;\
· 支持管道网络传输，第一个请求发出后，不用等待其回来，就可以发送第二个请求，可以减少整体的响应时间

但依然有问题：\
· 请求/响应头部未经压缩就发送，首部信息越多延迟越大，只能压缩body部分;\
· 发送冗长的首部。每次互相发送相同的首部浪费的资源较多。\
· 队头阻塞问题，服务器是按请求顺序进行响应的，前面的请求没有得到响应，后面的请求都被阻塞;\
· 没有请求优先级控制，且请求只能从客户端开始，服务端只能被动响应。

ii. HTTP2的优化

HTTP2是基于HTTPS的，所以安全性有保障。其性能改进点：

· 头部压缩：如果同时发送多个请求，它们的头是一样的或者相似的，协议会帮你消除重复的部分。即HPACK算法：客户端和服务器同时维护一张头信息表，所有字段都会存入这张表，生成一个索引号，以后就不发送同样的字段了，而是发送索引号，开销小，提高了速度。

· 二进制格式：头信息和数据体都采用了二进制，统称为帧：头信息帧，数据帧。这样就不用将明文转换为二进制了，可以直接解析二进制报文，提高了数据传输的效率。

· 数据流：HTTP2的数据包不是按顺序发送的，同一个连接里的连续的数据包，可能属于不同的响应，因此需要对数据包进行标记，以确定它属于哪个响应。\
每个请求或响应的所有数据包，称为一个**数据流**，每个数据流都有一个**唯一的编号，**客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。
另外，客户端可以**指定数据流的优先级**，服务器优先响应优先级高的请求。

· 多路复用：HTTP2可在一个连接中并发多个请求或响应。**移除了HTTP1.1的串行请求，不需要排队等待，消除了队头阻塞，降低了延迟，大幅提高了连接的利用率。**

·服务器推送：服务器不再是一味地被动响应，其可以主动地向客户端发送消息。将客户端可能用到的信息一并发送，可以减少后续的延迟。

缺点：

多个HTTP请求复用一个TCP连接，下层的TCP协议是不知道有多少个HTTP请求的。一旦发生了丢包，就会出发TCP重传机制，这条TCP连接的所有HTTP请求都必须等待这个丢了的包被重传回来。所以HTTP3把HTTP下层的TCP改成了基于UDP的QUIC.

iii. HTTP3

基于UDP的QUIC协议也可以实现数据的可靠传输：\
· 某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。\
· TLS升级到了1.3版本，头部压缩算法升级到了QPack\
· HTTP3建立连接只需3次握手，之前版本需要6次握手(TCP+TLS)。
