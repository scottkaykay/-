# 进程线程专题

单核CPU在某一瞬间只能执行一个进程，当进程需要从磁盘读取数据时，CPU不需要阻塞等待数据的返回，继续执行其他进程。一旦磁盘数据返回，CPU会收到**中断信号**，
此时再去执行之前的进程。

进程切换时，必须记录当前进程的运行状态信息，以便下次返回回来时继续执行。

## 进程的状态
               运行状态------------------
                 |  ^                   |
       时间片用完 |  | 调度              |  等待事件发生
                 v  |                   v
创建状态----->  就绪状态 <---------- 阻塞状态
                         事件完成
                         
此外，还有挂起状态，此时进程并没有占用物理内存空间,因为进程使用的空间可能并没有映射到对应的物理内存\
· 阻塞挂起状态： 进程在外存，等待某个事件的发生\
· 就绪挂起状态： 进程在外存，但只要进入内存即可开始运行。

## 进程控制结构 PCB

PCB,即进程控制块。主要包含：进程标识符，用户标识符（表示进程的归属用户），进程当前状态（上面说的），进程优先级，申请的资源清单，CPU相关信息（各寄存器的值）。
进程控制块的组织形式：链表，索引。主要用的链表（方便插入删除），将相同状态的进程链在一起。（就绪状态的进程链表为就绪队列，相同地，有阻塞队列）

## 进程控制

i. 进程创建：操作系统允许一个进程创建另一个进程，并允许子进程继承父进程所拥有的资源，当子进程被终止时，它继承的资源应该归还给父进程。同时，终止父进程也会中止其所有的子进程。
创建进程的流程：\
· 为进程分配一个唯一的进程标识号，并申请一个空白的PCB，PCB是有限的，如果申请失败则创建失败；\
· 为进程分配资源，如果资源不足，则会进入等待状态\
· 初始化PCB\
· 如果进程的调度队列能接纳新进程，则进程进入就绪队列，等待被调度运行；

ii. 终止进程

有三种方式：正常结束，异常结束，外界干预。\
· 查找需要终止的进程的PCB\
· 如果进程处于执行状态，立即终止该进程的执行，然后将CPU资源分配给其他进程\
· 如果其还有子进程，应该将所有子进程终止\
· 将该进程所有资源归还给父进程或操作系统\
· 将其从PCB所在队列中剔除

iii. 阻塞进程

当进程需要等待某事件完成时，调用阻塞语句把自己阻塞，一旦被阻塞等待，只能由另一个进程唤醒。\
· 找到要被阻塞的进程的PCB\
· 如果该进程为执行状态，保护其现场，再将其状态转为阻塞状态，停止运行\
· 将该PCB插入到阻塞队列

iv. 唤醒进程

· 在该事件的阻塞队列中找到相应进程的PCB\
· 将其从阻塞队列中取出，置其状态为就绪状态\
· 把该PCB插入到就绪队列

进程的阻塞和唤醒是一对功能相反的语句，如果某个进程调用了阻塞语句，一定会有与之对应的唤醒语句。

## 进程的上下文切换

各个进程是共享CPU资源的，不同的时候进程之间需要切换。由一个进程切换到另一进程运行，称为进程的上下文切换。

先看CPU上下文切换：\
多数操作系统支持多任务，可以支持多于CPU数量的任务同时运行。实际上，这不是并行的，而是并发的。任务是交给CPU运行的，CPU在执行任务前，需要知道任务从哪里加载，又从哪里开始运行。
**所以，操作系统需要帮助CPU设置好寄存器和程序计数器（PC）。CPU寄存器是一个容量小，速度极快的内存，程序计数器存储CPU正在执行的指令的位置，或即将执行的下一条指令的位置。
这叫CPU上下文。

CPU上下文切换就是把前一个任务的CPU上下文（CPU寄存器和程序计数器）保存起来，然后加载新任务的CPU上下文，运行新任务。系统内核会存储保存的CPU上下文信息，当此任务再次分配给CPU运行时，
CPU会重新加载这些上下文，使原来的状态不受影响，看起来就像是连续运行。

**根据任务不同，可以将CPU上下文切换分为：进程上下文切换，线程上下文切换，中断上下文切断。**

进程是由内核管理和调度的，所以进程切换只发生在内核态。**进程上下文切换包含：虚拟内存、栈、全局变量等用户空间资源，内核堆栈，寄存器等内核空间资源**\
通常会把交换的信息保存在进程PCB,当需要运行另外一个进程的时候，需要从这个进程的PCB取出上下文，恢复到CPU，使得该进程可以继续执行。

进程1  进程1上下文保存  加载进程2上下文  进程2

## 进程上下文切换有哪些场景

· 为保证所有进程得到公平调度，CPU时间被划分为一段段时间片，这些时间片被轮流分配给各个进程。当某个时间片耗尽，就会被系统挂起，切换到别的进程运行。\
· 进程在系统资源不足的情况下，需要等待资源满足后才能运行，这时候也会被挂起，操作系统调度其他进程运行。\
· 有优先级更高的进程需要运行时，当前进程会被挂起|
` 发生硬件中断时，CPU上的进程会被中断挂起，转而执行内核中的中断服务程序。

## 线程

单进程的问题：执行多任务时无法并发，效率低，多进程的维护开销较大，需要解决进程间通信。

**线程间可以并发运行并共享地址空间。**啥是线程？其实就是一条执行流程，是CPU调度和执行的最小单位，同一个进程内多个线程可以共享代码段没数据段，打开的文件资源。但每个线程有自己独立的寄存器和栈，确保线程的控制流是相对独立的。

线程的优缺点：

先说优点：\
· 一个进程中可以有多个线程\
· 各个线程间可以并发执行\
· 各个线程间可以共享地址空间和文件等资源

缺点：\
· 当进程中的一个线程崩溃，会导致该进程中其他线程都崩溃

## 进程线程的比较

· 进程是资源分配的基本单位，线程是CPU调度的单位。\
· 进程拥有一个完整的资源平台，而线程独享较少的必不可少的资源（寄存器和栈）\
· 线程同样具备就绪，运行，阻塞三种基本状态，同样有状态间 的转换\
· 线程能减少并发执行的时间和空间开销。

针对第四点，说明原因：\
· 线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如文件管理信息，内存管理信息。线程在创建的过程中，不会涉及资源管理信息，而是共享它们。\
· 线程的终止时间比进程快，因为线程释放的资源相比进程少很多。\
· 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间，这意味着同一个进程的线程都具有**同一个页表**，那么切换的时候就不需要切换页表。进程间切换需要切换页表，开销较大。\
· 由于同一进程的各线程间共享内存和文件资源，线程间进行数据传递的时候就不需要经过内核了，使得线程间数据交互效率更高了。

## 线程的上下文切换

· 当进程只有一个线程时，可以认为进程就等于线程\
· 当进程具有多个线程时，这些线程共享相同的虚拟内存和全局变量，这些资源在上下文切换时时不需要修改的。\
· 线程有自己的私有数据（寄存器和栈），这些数据在线程切换时需要保存。

· 当线程不属于同一个进程，则切换过程就跟进程上下文切换一样。\
· 两个线程属于同一个进程，因为虚拟内存是共享的，所以切换时，虚拟内存这些资源保持不动，只需要切换线程的私有数据，寄存器等不共享数据。

## 线程的实现

· 用户线程：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来管理；|
· 内核线程：在内核中实现的线程，是由内核管理的线程。
· 轻量级进程：在内核中支持用户线程。

用户线程和内核线程的关系： 多个用户线程对应同一个内核线程/ 每个用户线程对应一个内核线程/ 多个用户线程对应多个内核线程

i.用户线程

用户线程是基于**用户态的线程管理库**来实现的，线程控制块(TCB)也是库里面实现的，对于操作系统而言是看不到这个TCB的，它只能看到整个进程的PCB.
**所以，用户线程的整个线程管理和调度操作系统是不直接参与的，而是由用户级线程库函数完成线程的管理，包括线程的创建、终止，同步和调度。其模型是多个线程对应一个内核进程。

用户线程的优点：\
· 每个进程都需要有其私有的线程控制块列表，用来跟踪记录各个线程状态信息，TCB由**用户级线程库函数来维护。**可用于不支持多线程技术的操作系统\
· 用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，速度快。

缺点：\
· 由于**操作系统不参与线程的调度**，如果一个线程发起系统调用而被阻塞，那么该进程内其他线程都不能执行了;\
· 当一个线程开始运行后，除非它主动交出CPU使用权，否则它所在进程中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程；\
· 由于时间片分给进程，与其他进程相比，多线程执行时，每个线程得到的时间片比较少，执行会比较慢

ii. 内核线程

**内核线程是由操作系统管理的，线程对应的TCB自然是放在操作系统里的，线程的创建，终止和管理都是由操作系统负责。模型为一对一关系，一个用户线程对应一个内核线程。

内核线程的优点：\
· 一个进程中，如果某个内核线程发起系统调用而被阻塞，不影响其他内核线程的执行\
· 时间片分配给线程，多线程的进程获得更多的CPU执行时间。

缺点：\
· 在支持内核线程的操作系统中，由内核维护进程和线程的上下文信息。\
· 线程的创建，终止和切换都是通过系统调用的方式来进行，系统开销比较大。

## 轻量级进程LWP

是内核支持的用户线程，一个进程可以有很多个LWP,每个LWP和内核线程是一对一映射的，即每个LWP都和一个内核线程对应。LWP只能由内核管理并像普通进程一样被调度。

LWP与普通进程的区别在于它只有一个最小的执行上下文和调度程序所需的统计信息。

## 调度

选择一个进程运行是在操作系统中完成的，通常称为调度程序。

## 调度触发时机

进程状态转换：\
· 就绪状态----> 运行状态\
· 运行状态----> 阻塞状态\
· 运行状态----> 结束状态

## 调度算法

· 非抢占式调度算法。 挑选一个进程，一直让其运行，直到被阻塞或者结束，才调用另外一个进程，不会理时钟中断。\
· 抢占式调度算法。挑选一个进程，让该进程只运行某段时间，如果该时段结束，进程仍然在运行，则将其挂起，接着调度程序从就绪队列挑选一个进程。这种抢占式调度处理需要在
**时间间隔末端发生时钟中断，即时间片机制，把CPU控制返回给调度程序进行调度。

## 调度原则

· 如果运行的程序发生了I/O事件请求，则会阻塞进程等待数据返回，为了提高CPU利用率，调度程序需从就绪队列选择一个进程来运行。\
· 有的程序执行某个任务需要耗费大量的时间，造成系统的吞吐量降低，为了保证系统的吞吐率，调度程序需要权衡长任务和短任务进程的运行完成数量。\
· 从进程开始到结束，包含运行时间和等待时间，总的称为周转时间，如果进程运行时间短等待时间长，则周转时间长，调度程序需避免此类情况，进程的周转时间越短越好\
· 就绪队列中的进程也不能等太久，调度程序需考虑\
· 对于交互式比较强的应用，响应时间也是调度程序需要考虑的原则

CPU利用率， 系统吞吐量， 周转时间， 等待时间， 响应时间

## 单核CPU调度算法

· 先来先服务（非抢占式），每次从就绪队列选择最先进入队列的进程，一直运行到结束或被阻塞，再继续从队列中选择另一个进程，对长作业有利，适用于CPU繁忙型，不适合IO繁忙型\
· 最短作业优先：优先选择运行时间最短的进程来运行，有利于提高系统吞吐量\
· 高响应比优先调度： 权衡了短作业和长作业。每次进行进程调度时，**先计算响应比优先级，然后把响应比优先级最高的进程投入运行。公式：\
优先权=（等待时间+要求服务时间）/要求服务时间

    · 两个进程的等待时间相同， 要求服务时间越短，响应比越高，即短作业进程更容易被选中\
    · 两个进程的要求服务时间相同，等待时间越长，响应比越高，即长作业更容易被选择，

· 时间片轮转调度算法：最古老，最简单，最公平，使用最广的算法。每个进程被分配一个时间段，允许在该时间段内运行进程。\
    · 如果时间片用完，进程还在运行，会把此进程从CPU释放出来，把CPU分配给另一个进程；\
    · 进程在时间片结束前阻塞或结束，CPU立即切换\
    · 如果时间片太短，会导致过多的进程上下文切换，降低CPU效率\
    · 时间片太长可能引起对短作业进程的响应时间变长，通常时间片设为20ms~50ms
    
· 最高优先级调度：时间片轮转将所有进程的重要性一视同仁，但多用户计算机系统希望调度程序从就绪队列中选择优先级最高的进行运行，称为最高优先级调度算法

    · 静态优先级：进程创建的时候，优先级就已经确定了，整个运行时间优先级都不会变化\
    · 动态优先级： 根据进程的动态变化调整优先级，如果进程运行时间增加，则降低其优先级，如果进程的等待时间增加（就绪队列里的），则提高其优先级。\
    · 抢占式和非抢占式，缺点是可能会导致低优先级的进程永远不会运行。
    
· 多级反馈队列调度

是时间片轮转和最高优先级的综合和发展。\
    · 多级：表示有多个队列，每个队列优先级从高到低，优先级越高时间片越短。\
    · 反馈：当有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而运行优先级高的队列。\
    
银行设置了多个排队（就绪）队列，每个队列都有不同的优先级，各个队列优先级从高到低，同时每个队列执行时间片的长度也不同，优先级越高的时间片越短。

新客户（进程）来了，先进入第一级队列的末尾，按先来先服务原则排队等待被叫号（运行）。如果时间片用完客户的业务还没办理完成，则让客户进入到下一级队列的末尾，以此类推，直至客户业务办理完成。

当第一级队列没人排队时，就会叫号二级队列的客户。如果客户办理业务过程中，有新的客户加入到较高优先级的队列，那么此时办理中的客户需要停止办理，回到原队列的末尾等待再次叫号，因为要把窗口让给刚进入较高优先级队列的客户。
    

