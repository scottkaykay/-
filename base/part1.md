## C++基础知识（每部分30题）

### 1.拷贝构造函数相关

类中没有显式定义拷贝构造函数时，编译器会隐式定义一个缺省的拷贝构造函数，是一个inline,public的函数。形式为： 类名：：类名(const 类名 &) 
当自己定义了拷贝构造函数后，系统不再提供默认拷贝构造函数。

调用情况：\
· 将一个已存在的对象赋值给新对象；
· 对象作为函数的赋值参数，调用此函数生成新对象；
· 函数返回值为类对象，函数调用完返回时

赋值运算符重载函数是要把一个已存在的对象的各成员的值赋给另一个已存在的对象。\
注意，系统提供的缺省的拷贝构造函数只有简单的功能：即把一个对象所有成员的当前值赋值给新对象，只进行了浅拷贝。如果需要别的操作，则必须定义自己的拷贝构造函数。

如果对象存在动态成员，浅拷贝就会出现问题。比如成员变量中有指针，如果采用默认的拷贝构造函数，会使新对象的指针与原对象的指针指向同一内存，最后析构2次，
出现错误。解决方法是重写拷贝构造函数，对指针重新进行内存分配。

示例如下：

```C++
#include<iostream>
#include<assert.h>

using namespace std;
class Rect
{

    public:
        Rect()
        {
            p=new int(100);
        }
        Rect(const Rect& r)
        {
            width=r.width;
            height=r.height;
            p=new int(100);
            *p=*(r.p);
        }
        ~Rect()
        {
            assert(p!=NULL);
            delete p;
        }
private:
    int width;
    int height;
    int *p;
    };
int main()
{
    Rect rect1;
    Rect rect2(rect1);
    return 0;
}
```

#### 几个细节

i. 为什么拷贝构造函数必须是引用传递，不是值传递？\
避免引起递归引用。对象以值方式传递时，会生成一个临时对象，调用拷贝构造函数赋值，如果A的拷贝构造函数以值方式传递一个类A对象，会再次调用A的拷贝构造函数，
造成无限递归。

ii. 拷贝构造函数的作用\
复制对象，用对象的实例初始化另一个实例。

iii. 参数传递过程\
使用值传递：对于内置数据类型，直接拷贝赋值给形参，对于类类型，会调用拷贝构造函数进行初始化；
使用引用传递，无论是内置数据类型还是类类型，传递的都是地址值，属于简单类型，不会有拷贝构造函数的调用。

iv. 拷贝构造函数里能调用private成员变量么？\
当然可以。

v. 如何判断拷贝构造函数？\
第一个参数是： X&/ const X&/ volatile X&/const volatile X&

如果有其他参数，且其他参数有默认值，则该函数是拷贝构造函数。

vi. 一个类中可以存在多个拷贝构造函数吗？\
可以的。如： X(const X&); X(X&);  但是要注意，一个类中只有参数为X&的拷贝构造函数，是不能使用const X/volatile X的对象进行拷贝初始化的。

vii. 构造函数可以重载，但析构函数不行。为什么析构函数一般定义为虚函数？\
因为虚函数是实现多态的基础，通过基类的指针析构子类对象时，如果析构函数不是虚函数，那么只会调用基类的虚函数，子类的析构函数不会被调用，造成
内存无法释放。

### 2.makefile相关

make命令是GNU编译工具。它用于编译大量相互关联的源代码，可实现项目的工程化管理，提高开发效率。\
makefile文件告诉make源代码文件间的链接关系，依赖关系，从而准确地编译和链接成一个应用程序。
使用makfile定义规则，可以避免重复编译：\
· 如果工程从没有被编译过，所有的.c文件都要编译并链接。
· 如果有编译后的目标文件，但此工程的某些.c文件被改了，就只编译这些被修改的.c文件并链接目标程序；
· 如果有编译后的目标文件，但此工程的头文件改了，需要编译引用了这几个头文件的.c文件，并链接目标程序。

### 3. linux 下 GDB调试过程

i. 启动调试

gcc -g test.c -o mytest  //gcc编译，编译文件，生成mytest可执行程序。注意一定要加入调试信息：-g
gdb mytest.out  //进入gdb调试

ii. 显示当前代码： l (即list),一次只显示10行，如果想继续查看，继续使用该命令。

iii.在某行打断点： b 行号

iv. 开始运行程序： r

v.逐步执行 : s

vi. 重复上条命令： 直接enter

vii. 查看某个变量的变化： PRINT 变量名

viii. 查看变量类型 : WHATIS 变量名

ix. 看函数的堆栈： BT

x. 结束调试： FINISH

xi. 进入下一次调试： N

xii. 退出调试： Q

### 4. class和struct的区别

最大的区别在于struct的数据访问控制是public的，class的数据访问控制默认是private的。struct可以有成员函数，可以继承，可以实现多态！\
class可以作为定义模板的参数。
https://www.cnblogs.com/joean/p/4609279.html

### 5. new与malloc的区别

先拓展一点：内存分配函数还有 calloc, realloc.\
calloc在返回指向内存的指针之前将它初始化为0， calloc的参数包括所需元素数量和每个元素的字节数\
realloc函数用于修改一个已经分配的内存块的大小，可使一块内存扩大或缩小。如果扩大，原内存块保持不变，在内存尾部增加新的内存块，不进行初始化。\
如果缩小，原来的内存块从尾部进行删减。如果原内存无法扩充，则开辟一块新内存，复制原内存的内容，然后原内存失效。

来看new 与 malloc 的区别：\
· new/delete是关键字，需要编译器支持。malloc/free是标准库函数，需要头文件支持。\
· 使用new 进行内存分配不需要指定内存块大小，malloc需要显式地指出所需内存大小。\
· new操作成功时，返回对象类型的指针，类型严格与对象匹配，不需要进行强制类型转换。malloc内存分配成功返回的是void*,需要进行强制类型转换。\
· new分配内存失败会抛出bad_alloc异常，malloc内存分配失败会返回NULL.\
· new可以重载，malloc不允许重载\
· new从自由存储区上为对象动态分配内存，malloc从对上申请内存；\
· 对于自定义类型，new会先调用operate new函数申请足够的内存，然后调用类型的构造函数进行初始化，最后返回自定义类型指针。delete先调用析构函数，
然后调用operate delete函数释放内存，

### 6. define和const的区别

· define 是在编译的**预处理**阶段起作用，const实在编译运行时起作用；\
· define知识简单的字符串替换，没有类型检查。const有对应的数据类型，有类型检查。\
· define只是简单地替换，用多少次就换多少次，所以内存会有多个备份，const定义的只读变量在程序运行过程中只有一份备份。

const优点：

· const有对应的数据类型，可在编译时提供类型检查；\
· const在运行时只有一份备份，节省空间;\
· const常量可以被调试，宏定义常量不行。

### 7. const和static的用法

static
