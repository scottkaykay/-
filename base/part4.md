## 并发编程三要素

· 原子性：一个操作或多个操作，要么全部执行，要么全部不执行。\
· 可见性：指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他线程可以立即看到修改的结果。实现可见性：synchronized 或者lock:保证同一时刻只有一个线程获取锁执行代码，
锁释放之前把最新的值刷新到主内存，实现可见性。\
· 有序性：程序的执行顺序按照代码的先后顺序来执行。

## 多线程的价值在何处？

· 可以发挥多核CPU的优势，充分利用CPU资源\
· 防止阻塞：从程序运行效率来看，单核CPU不仅不能发挥多线程的优势，还会因为多线程上下文切换而降低程序整体的效率。但还是要应用多线程，就是为了防止阻塞，如果有个线程在等待IO返回的数据，其他线程可以利用
CPU继续运行。

## 便于建模

假设有一个大的任务A,单线程编程，那么考虑的东西就会很大，容易出现纰漏。如果大任务分解成几个小任务，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。

## 创建线程的方式？

· 通过Thread类创建线程类\
· 通过Runnable接口创建线程类\
· 通过Callable和Future创建线程

对比：

· 使用 Runnable,Callable 接口创建多线程\
线程类只是实现了Runnable接口或Callable接口，还可以继承其他类，多个线程可以共享同一个目标对象，非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU,代码和数据分开，形成清晰的模型。
不好的一点是编程稍复杂，如果要访问当前线程，必须使用Thread,currentThread()方法。

· 使用继承Thread类的方式创建多线程\
编写简单，如果要访问当前线程，直接使用this即可获得当前线程，缺点是继承了Thread类，不能再继承别的类

· Runnable和Callable

Callable重写的方法是call(),  Runnable重写的方法是run() \
Callable的任务执行后可返回值，而Runnable是不能返回值的\
Call方法可以抛出异常，run方法不可以\
运行Callable任务可以拿到一个Future对象，表示异步计算的结果。

## 线程池

为什么要使用线程池？等到程序运行才创建线程，如果需要创建大量线程，则需要消耗很多资源，运行效率不高。
线程池实现：

优点：\
· 重用存在的线程，减少对象创建销毁的开销\
· 可有效地控制最大并发线程数，提高系统资源的利用率，同时避免过多资源的竞争\
· 提供定时执行，定期执行，单线程，并发数控制等功能

## Java里的volatile关键字

当一个共享变量被volatile修饰的时候，会保证修改的值被立即更新到主存，以保证可见性。

## 文件存储了10亿条销量数据，如何找出前10000大的数据？

·这个问题还是建立最小堆来解决。

思路：先拿10000个数建堆，然后依次添加剩下的元素，如果大于堆顶的数（10000个数中最小的），将这个数替换堆顶，并调整堆结构维持最小堆特性。这样遍历完后，堆中的10000个数就是所需的最大的10000个。建堆时间复杂度为O(NlogN),算法的时间复杂度为NMlogM, M为10000，N为10亿，即添加元素的外循环。优化：将10亿个数据分组存放，比如分别放在1000个文件中，这样处理就可以分别在每个文件10^6个数据中找到最大的10000个数，最后合并到一起找出最终的结果。

· 单机+单核+足够大内存  可使用排序方法\
· 单机+多核+足够大内存  分治+排序\
· 单机+单核+受限内存   需要将原数据文件切割成一个个的小文件，直至小文件小于内存大小，再放到内存中处理，使用排序的方法\
· 多机+受限内存 将数据分发到多台机器上，每台机器采用上一条的策略处理本地数据

## 海量数据中的重复问题

一般可以通过位图法实现。例如已知某个文件内包含一些电话号码，每个号码为=为8位数字，统计不同号码的个数。 8位数字能表示的最大十进制数为99999999，
每个数字对应于位图中的一个bit位，那么存储8位整数大约需要99Mb(1B=8bit,99/8=12.375MB)

## STL 中sort的底层实现

sort结合了快速排序，插入排序和堆排序。vector, deque适用sort算法。\
排序算法的选择：数据量大的时候采用快速排序，一旦分段后的数据量小于某个门槛（比如数据量小于16），为避免快排递归调用带来过大的额外负荷，改用插入排序。如果递归层次过深，采用堆排序。

```C+
template <class Size>
inline Size __lg(Size n)  //计算递归深度
{
    Size k;
    for(k=0;n>1;n>>=1) ++k;
    return k;
}
```

```C++
//sort源码
template <class _RandomAccessIter>
 
inline void sort(_RandomAccessIter __first, _RandomAccessIter __last) {
 
__STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
 
__STL_REQUIRES(typename iterator_traits<_RandomAccessIter>::value_type,
 
_LessThanComparable);
 
if (__first != __last) {
 
__introsort_loop(__first, __last,
 
__VALUE_TYPE(__first),
 
__lg(__last - __first) * 2);
 
__final_insertion_sort(__first, __last); //插入排序
 
}
 
}
```

进来之后会首先进行判断元素是否大于__stl_threshold，__stl_threshold是一个常量值是16，意思就是说我传入的元素规模小于我们的16的时候我们就没必要采用我们的内省式算法，直接退回去采用我们的插入排序。

如果说我们的元素规模大于我们的16了，那就需要去判断如果我们是不是能采用快速排序，怎么判断呢？快排是使用递归来实现的，如果说我们进行判断我们的递归深度没有到达我们的最深层次上边的函数已经看过了，最深是2\*lg（n）。那我们就去使用我们的快速排序来进行排序

如果说大于我们的最深层次的话，这里就会采用我们的堆排序，进行排序

并不是说整个传进来的数组都是这个过程，这里我们是进行的一次排序，他可能是我传入的数组，也可能是我在进行快排分割之后的左半部分，排序结束之后再去排我的右半部分，所以可以看上边我们的元素规模是不是大于__stl_threshold这个阈值的时候是一个while循环。

堆排序比较和交换次数比快速排序多，所以平均而言比快速排序慢，即常数因子比快速排序大，如果需要的是排序，那么绝大多数场合都应该用快速排序而不是别的算法。有时候要的不是排序，而是与之相关的东西，如最大的前n个元素，这时候就适用于堆排序了，用堆排序可以在N个元素中找到topK,时间复杂度为O(NlogK),空间复杂度O(K),快排的空间复杂度为O(N),可见堆排序更省空间。另外一个适合用堆的场合是优先队列，需要一组不停更新的数据中不停地找最大最小元素。

## 循环队列

结构体：\
```C++
struct queue{
    int count;//记录元素个数
    int front; //队首
    int rear;  //队尾
    int data[MAX_SIZE]; //记录元素的值
}Queue;
```
循环链表的优点就是不浪费空间，如果队列不是循环的，元素出队会往上动一个单位，那么下面的空间就无法利用到了。\
队列空的条件： Q.front==Q.rear \
队列满的条件： (Q.rear+1)%MAX_SIZE==Q.front

实现见：


## 如何同时操作多个服务器

· 群控软件。

· 利用SHELL脚本完成服务器批量管理。前提：在待执行命令的各个服务器上设置了免密登录（https://blog.csdn.net/zoombinde/article/details/51902208）

步骤（假设有4台机器：192.168.2.1~ 192.168.2.4）：\
· 指定一台主机为信任主机： 比如指定192.168.2.1为信任机，那么就在这台机器上运行：ssh -keygen -t rsa //一路回车，生成密钥\
scp .ssh/id_rsa.pub 192.168.2.2:~/    //把密钥拷贝到其他远程机器\
ssh 192.168.2.2 'cat id_rsa.pub>>.ssh/authorized_keys'  //在远程机器上生成认证文件，经过这几步，从192.168.2.1登录192.168.2.2就不需要输入密码了，同样的步骤再对其他机器执行\
· 在信任机器上创建hostlist文本（和脚本放在同一目录），文本文件hostlist可以如下：\
192.168.2.2 \
192.168.2.3 \
192.168.2.4

· 创建doCommand.sh脚本

```
#!/bin/sh
do Command()
{
    hosts=`sed -n '/^[^#]/p' hostlist`
    for host in $hosts
        do
            echo ""
            echo HOST $host
            ssh $host "$@"
        done
    return 0
}

    if [ $# -lt 1]
    then
        echo "$0 cmd"
        exit
    fi
    doCommand "$@"
    echo "return from doCommand"
```

· 执行命令（先对doCommand.sh脚本增加执行权限：chmod u+x doCommand.sh）: 如 ./doCommand.sh "ls al /root/" 脚本就会在每台机器上执行 "ls al /root/这个命令， 并返回结果到信任主机上。

## 大文本文件找出词频最高的10个词

一边读入一边统计，并且要去掉标点符号，以空白分离单词。要找高频词，所有的单词都是要遍历的。为使时间效率更高，可采用类似二叉搜索树的方法，单词以字母为序，如abc排在edf前面，也排在acd前面，每读入一个词就进行二叉搜索树的查找操作，如果找到了对应的字段加一，没找到就插入。其次，还要维护大小为10的数组，存储词频最高的10个数，按降序排列，每次在二叉搜索树中查找到单词，更新出现的次数，与前10数组进行比较，如果这个词已经出现在数组里，则直接更新，如果大于10个数里面最小的那个词频，则删除这个元素，插入当前单词。

## DNS缓存有哪些

浏览器缓存：浏览器会保存一段时间你访问过的网址的DNS信息，不同的浏览器保存的时长不等\
系统缓存：如果上面的步骤没找到对应的DNS信息，浏览器会尝试调用系统缓存来继续查找这个网址对应的DNS信息\
路由器缓存：如果还是没有找到对应的IP,那么浏览器会接着发送一个请求道路由器上，然后路由器在自己的路由器缓存查找相关记录，一般路由器也存有DNS信息。
