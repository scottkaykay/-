## 内存泄漏检测工具

https://blog.csdn.net/qq_23350817/article/details/90641856

· 常发性内存泄漏：发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏\
· 偶发性内存泄漏：发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生\
· 一次性内存泄漏：发生内存泄漏的代码只会被执行一次\
· 隐式内存泄漏：程序在运行过程中不停地分配内存，直到运行结束的时候才会释放内存。严格来说并没有发生内存泄漏，因为最后都释放了，但是对于一个服务器程序，需要运行很久的时间，不及时释放内存
可能会导致内存资源耗尽。

### Visual Leak Detecter,  Windows , C/C++

· 只需包含头文件vld.h，并添加提供的lib\
· 结果输出到VC的调试窗口中\
· 设计思路： 注册CrtSetAllocHook钩子函数，使用VC自带的CRT Debug Heap, 可获得内存泄漏点的调用堆栈，得到完整的内存泄漏数据\

### Valgrind , Linux, C/C++

· 加入memwatch.h, 编译时加入 -DMEMWATCH -DMW_STDIO  以及memwatch.c\
· 输出文件名称为memwatch.log,在程序执行期间，错误提示都会显示在stdout上\
· 设计思路：根据软件的内存操作维护一个有效地址空间表和无效地址空间表（进程的地址空间）|
· 优缺点：\
i. 能检测未初始化的内存\
ii. 使用已经释放了的内存\
iii. 使用超过malloc分配的内存空间\
iv. 对堆栈的非法访问\
v.申请的空间是否有释放

### debug_new , Linux/Windows , C++

· 包含头文件debug_new.h, 链接debug_new.cpp\
· 控制台console输出\
· 设计思路：通过重载new,delete操作符来捕获内存申请/释放请求，并在程序内部维护一个全局静态变量的哈希链表。在new操作符中，不仅仅分配用户所要求的内存，在为每次分配的内存添加一个头部，存储此次分配的位置信息和链表指针，new返回的是分配的这块内存加上头部偏移之后的值，将此返回值做哈希计算添加到哈希链表中。delete的时候先根据要释放的指针地址做hash计算，然后遍历数组hash值处的链表进行查找，如果找到将该节点移出，未找到就abort。程序结束之后，检查哈希链表中是否还有未释放的内存块来确定是否有内存泄漏。优点是跨平台，仅用C++程序。
