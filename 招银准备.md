## 系统调用的过程

https://blog.csdn.net/chengonghao/article/details/51288084

系统调用是操作系统提供的一组函数，只能在内核态中执行，用户程序平时运行在用户态，通过系统调用可进入内核态。

比如读写磁盘的I/O操作，使用int 0x80 硬件中断指令，使程序从用户态进入内核态，同时由硬件负责保存用户态的执行现场，并把程序的用户态堆栈转换为内核态堆栈。
eax寄存器存储的是系统调用号（标识着不同的系统调用），通过4*(eax) (32位操作系统指针4个字节)找到对应系统调用函数的地址(在系统调用表sys_call_table中找到对应的函数入口地址)
执行完毕后返回，恢复用户程序执行现场，继续执行程序。

## 动态库，静态库，如何调用

库：可执行代码的二进制形式，可以被操作系统载入内存执行，库有两种：静态库(.a .lib) 动态库(.so  .dll)，静态，动态指链接

### 静态库

· 静态库对函数库的连接在编译阶段就完成了，即库连接到了代码中\
· 程序运行时与函数库没有瓜葛，移植方便\
· 浪费空间和资源，多个程序就存在多份拷贝，不利于程序的更新，修改和发布

### 动态库

· 动态库把一些库函数的链接载入推迟到程序运行的时期。\
· 可实现进程之间的资源共享\
· 使程序升级，更新，发布变得方便\

### 调用动态库

Linux下：\
· void* dlopen(const char* pathname,int mode); 函数以指定模式打开指定的动态链接库文件，并返回一个句柄给调用进程\
· void* dlsym(void* handle,const char* symbol); dlsym根据动态链接库操作句柄与符号，返回符号对应的地址，使用这个函数不仅可以获取函数地址，也可以获取变量地址。\
· int dlclose(void* handle); dlclose用于关闭指定句柄的动态链接库，只有当此动态链接库的使用技术为0的时候，才会真正被系统卸载。\
· const char* dlerror(void);当动态链接库操作函数执行失败时，dlerror可以返回出错信息，返回为NULL表示操作函数执行成功。

Windows下：\
· 调用LoadLibrary以加载DLL和获取模块句柄\
· 调用GetProcAddress,以获取指向应用程序\
· 使用完DLL后调用FreeLibrary
