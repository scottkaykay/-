## 守护、僵尸、孤儿进程的概念？

· 孤儿进程：其父进程执行完成或被中止后依然运行的一类进程。它们将被init进程（进程号为1）收养，并由init进程完成对它们的状态收集。\
· 僵尸进程：父进程创建子进程，子进程结束退出，但父进程并没有调用wait/waitpid，子进程的描述符依然保留在系统中，如果父进程及时调用wait/waitpid处理即可消除。
如果父进程在子进程结束之前推出，子进程将由init进程收养，init进程作为父进程对僵尸状态的进程进行处理。\
僵尸进程的危害：如果父进程不调用wait/waitpid，那么子进程描述符占用的资源就不会被释放，进程号就会被一直占用，如果出现大量的僵尸进程，将可能因为没有进程号而无法产生新的进程。\
消灭方式：\
· 外部消灭：通过kill发射SIGTERM 或 SIGKILL信号消灭产生僵尸进程的进程，这样一来，其产生的僵尸进程就会成为孤儿进程，被init进程收养，init进程调用wait，释放它们所占用的系统资源。\
· 内部消灭：子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号，在信号处理函数中调用wait处理僵尸进程。

·守护进程：守护进程是在后台运行的一类特殊进程，不受终端控制，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，一直运行到系统关闭。


## 关于死锁

多个进程由于互相等待对方持有的资源而造成的谁都无法执行的情况称为死锁。

### 死锁的必要条件

互斥使用，不可剥夺，请求和保持，环路等待

互斥条件：进程对于分配到的资源，不允许其他进程访问，如果其他进程想要访问此资源，则需要等到当前资源使用完后释放;\
请求与保持：进程获得一定的资源后，又对其他资源发起请求，但其他资源被别的进程所占有，此时请求被阻塞，但进程并没有释放自己占用的资源；\
不可剥夺：进程获得分配的资源，在使用完成前不可被剥夺，只有使用完成后自己释放；\
环路等待：形成死锁时，必然存在进程资源间的环形链。

### 死锁处理方法

· 死锁预防：破坏不可剥夺条件，破坏请求与保持（进程执行前，一次性申请所有需要的资源），破坏环路等待（对资源编号，进程只能按编号顺序访问资源）\
· 死锁避免：银行家算法，其主要任务就是判断满足请求后，是否会进入不安全状态，如果会，则拒绝请求。\
根据可用资源，观察是否可以满足其中某个进程所有的需求，如果没有，则会出现死锁。如果有，中止该进程，将该进程分配的资源归入可用资源，然后利用这些可用资源看看是否
可以满足某个进程的需求，循环前面的步骤依次判断，直到所有进程中止，才是安全的。

## mmap内存映射

基本概念：\
mmap是一种内存映射文件的方法，将文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址一一对应。实现这样的映射关系后，进程就可以采用**指针**的方式
对这段内存进行读写操作，系统会自动回写脏页面到对应的文件磁盘上，不必调用read，write等系统调用函数就可以实现文件操作。\
进程的虚拟地址空间由多个虚拟内存区域构成，虚拟内存区域是一个同质区间，即具有相同特性的一段连续的地址范围。linux内核使用vm_area_struct结构来表示一个虚拟内存区域，
由于不同质的虚拟内存区域功能和机制都不相同，所以一个进程使用多个vm_area_struct表示不同类型的虚拟内存区域。各个vm_area_sruct使用链表或树形结构连接，方便快速访问。\
vm_area_struct包含虚拟内存区域的起始地址和终止地址，包含一个vm_ops指针，可引出所有针对这个区域可使用的系统调用函数，这样，进程就可以通过vm_area_struct结构体获取对这个虚拟内存区域操作所需用到的全部信息。\
mmap的作用就是创建这样的结构体并将其与文件的物理磁盘地址相连。

实现过程：

i. 进程启动映射过程，并在虚拟地址空间建立虚拟映射区域

· 进程在用户空间调用mmap函数，启动映射过程，在虚拟地址空间中寻找一段空闲且满足要求的连续虚拟地址，为其分配vm_area_struct结构，初始化完成后，将结构插入进程的虚拟区域链表或树中。\
ii.调用内核空间的mmap系统调用函数，实现虚拟地址空间与文件物理地址间的一一映射关系。\
iii. 进程发起对映射空间的访问，引发缺页异常，实现文件内容到物理主存的拷贝。缺页异常会进行一系列判断，确定无非法操作后，内核发起请求调页过程。调页过程先在交换缓存空间寻找需要访问的页，如果没有就调用
no page把所缺的页从磁盘装入到内存，接下来进程就可以对这块内存进行读写操作。如果写操作改变了其内容，一段时间后系统会自动回写脏页面到对应的磁盘地址。如果需要立刻保存，可使用
mysync来强制同步，\

为什么效率高：

常规的文件操作为了提高效率和保护磁盘，引入了页缓存机制。读文件时需要将文件页从磁盘拷贝到页缓存中，由于页缓存在内核空间，不能被用户进程直接寻址，所以还要将页缓存中的数据页再次拷贝到
内存对应的用户空间，故经历了两次拷贝。同样地，写操作时，待写入的buffer在内核空间无法直接访问，需要先拷贝到内核空间对应的内存，再回写到磁盘中。\
使用mmap操作文件，创建虚拟内存区域，建立虚拟地址和磁盘地址的映射，是没有任何数据拷贝操作的。后面进程发起对映射区域的访问时，发现数据并不在内存中，引起缺页异常，
通过调页过程将磁盘数据直接**传入用户空间**供进程使用，所以是一次数据拷贝，效率更高。

优点：\
· 对文件的读取操作跨过了页缓存，减少了数据拷贝次数，用内存读写取代I/O读写提高了读写效率\
· 实现了内核与用户空间的高效交互，两空间各自的修改操作可直接反映在映射区域，从而被对方空间及时捕捉\
· 提供进程间共享内存和相互通信的方式。即便是没有亲缘关系的进程，都可以将自身用户空间映射到同一个区域，通过对各自映射区域的改动，达到进程间通信和进程间共享的目的。\
· 可实现高效的大规模数据的传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但这进一步会造成大量的I/O操作，极大影响效率。可以使用mmap解决。

## 内核模式和用户模式

用户模式到内核模式：系统调用和硬件中断

内核模式：内核里面存放的是操作系统内核代码和数据，是被所有程序共享的，在程序中修改内核数据是极其危险的，可能会破坏操作系统的稳定性，还会影响其他程序。所以
操作系统禁止用户进程访问内核空间。\
如要访问内核空间，必需借助操作系统提供的API函数，执行内核提供的代码，让内核自己来访问，这样才能保证内核空间的数据不会被随意修改，才能保证操作系统本身的稳定性。
用户程序调用系统API成为系统调用，发生系统调用时会暂停用户程序，转而执行内核代码，访问内核空间，称为内核模式。\
用户模式：用户空间保存的是用户程序的赛马和数据，是程序私有的，其他程序一般无法访问。执行用户程序的代码时，称为用户模式。

## 为什么区分两种模式

内核最主要的任务是管理硬件，如果程序要进行输入输出，内存分配，响应鼠标事件等有关于硬件的操作时，需要使用内核提供的接口，但用户程序是不安全的，内核对用户也是不信任的。程序调用内核接口时，内核要做各种校验，防止出错。

## 为什么内核和用户程序要共享地址空间

让内核拥有完全独立的地址空间，相当于内核处于一个独立的进程中，这样每次系统调用都会导致进程切换，进程切换的开销较大，不仅需要寄存器进栈出栈，还会导致CPU缓存失效，MMU页表缓存失效，导致内存访问在一段时间非常低效。\
如果内核和用户共享地址空间，发生系统调用进行的就是模式切换，模式切换仅仅需要寄存器进出栈，不会导致缓存失效。效率大大提高。

## CPU密集型和IO密集型

· CPU密集型，即计算密集型，指的是系统的硬盘，内存性能相对于CPU要好，系统运作的大部分状况是CPU Loading 100%，CPU要读/写 IO, IO在很短的时间完成，而CPU还有很多运算需要处理，大部分时间Loading很高。要高效地利用CPU，计算密集型 任务同时进行的数量应等于CPU的核心数。由于任务主要消耗CPU资源，因而代码执行效率相当重要，应采用运行速度快的语言如C,C++.

· IO密集型，指系统的CPU性能相对于硬盘和内存更好，系统运作大部分状况是CPU在等 IO的读写操作，此时CPU占用率不高。涉及到网络，磁盘IO的任务都是IO密集型任务，这类任务的特点是 CPU消耗很少，任务的大部分时间都在等待IO操作完成。对于IO密集型任务，任务越多，CPU效率越高，但也有个限度。由于大部分时间都花在IO上，使用更快的语言产生的优化效果几乎忽略不计，此时可选用开发效率更高的脚本语言。
