# TCP可靠机制

TCP通过序列号，确认应答，重传，连接管理，窗口机制等实现可靠传输。

## 重传机制

### 超时重传

发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的ACK确认应答报文，就会重发该数据。应用场景：**数据包丢失，确认应答丢失**。

RTT:往返时延，即数据包的往返时间。超时重传时间以RTO表示，RTO的大小不同会造成不同的结果：\
· RTO较大时，重发就慢，丢了半天才重发，效率低\
· RTO较小时，可能导致包没有丢还会重发的情况，重发更快，容易加重网络拥塞，导致更多的超时，更多的重发。因而，合理的RTO是非常重要的。

**超时重传时间RT0应略大于报文往返时间RTT**

由于网络状况是波动的，所以RTT的值也是波动的，超时重传时间也是动态变化的

Linux如何计算RTO？

· 采样RTT的时间，然后进行加权平均，算出一个平滑的RTT值；还要采样RTT的波动范围，防止RTT有大的波动很难被发现的情况。
· 首次计算RTO：

SRTT=R1   DevRTT=R1/2   RTO=μ*SRTT+σ*DevRT = μ*R1+σ*(R1/2)

· 后续计算RTO,R2为最新测量的RTT:

SRTT=SRTT+ α(RTT-SRTT) = R1+ α*(R2-R1)

DevRTT = (1-β)*DevRTT+ β*(|RTT-SRTT|) = (1-β)*(R1/2)+ β*(|R2-R1|)

RTO=μ*SRTT + σ*DevRTT

超时重发的数据再次超时的时候，又需要重传，重传的时间间隔加倍。超时周期可能会比较长，就引入了快速重传机制。

### 快速重传

这是一种数据驱动方式的重传。当发送端收到三个重复的ACK报文时，会在定时器过期前，重传丢失的报文段。虽然快速重传解决了超时时间的问题，但发送端不知道具体重传哪些数据。如前5个报文，第二个报文丢了，发了三个ACK2，发送端知道第二个报文没收到，但不知道第三，四，五个报文是否收到了。为了解决这个问题，出现了SACK

### SACK 选择性确认

这种方式需要在TCP头部**选项字段**加入SACK，可以将缓存的地图发送给发送方，这样发送方就知道哪些数据收到了，只需重传丢失的数据。如果要支持SACK，则双方都要支持，Linux下可通过net.ipv4.tcp_sack打开。

### Duplicate SACK

使用SACK告诉发送方哪些数据被重复接收了，SACK小于ACK的值，说明收到了重复的报文


## 滑动窗口

TCP每发送一个数据，都要进行一次应答，上一个应答收到了，再发送下一个数据。这样的通讯效率比较低，如果数据报的往返时间长，更是无法容忍。窗口可以解决这个问题，即便在往返时间较长的情况下，也不会影响到通信效率。

窗口大小：指无需等待确认应答，可以直接发送数据的最大值。窗口实际上是操作系统开辟的一个缓存空间，在没有收到确认应答前，必须在缓冲区保留已发送的数据，只有收到确认应答后，才能在缓冲区中将对应的数据清除。

### 窗口大小的决定

TCP头部window字段，即窗口大小。这个字段告诉发送方接收端还有多少缓冲区可以接收数据，于是发送端根据这个接收端的处理能力来发送数据，避免导致接收端处理不过来。所以，窗口大小主要由**接收方的窗口大小来决定**。

发送方窗口组成：\
· 已发送已收到确认应答的\
· 已发送未收到确认应答的\
· 未发送但总长在接收方处理范围内\
· 未发送但总长超出了接收方处理范围

程序中使用三个指针来表示：其中两个指针是绝对指针，一个指针是相对指针\
· SND.WND:表示发送窗口的大小\
· SND.UNA:一个绝对指针，指向的是**已发送但未收到确认的第一个字节**的序列号\
· SND.NXT:一个绝对指针，指向的是**未发送但可发送范围内的第一个字节的序列号**\
· 相对指针，SND.UNA+SND.WND可指向未发送但在可发送范围外的第一个字节。

所以，可用窗口大小=SND.WND - (SND.NXT-SND.UNA)

接收方窗口：\
· 已成功接受并确认的数据\
· 未收到但可以接受的数据\
· 未收到但不可以接受的数据（超出了处理能力）

可使用两个指针表示：\
· RCV.WND:接收窗口的大小\
· RCV.NXT:指向期望从发送方发送来的下一个数据字节的序列号\
· 相对指针， RCV.WND+RCV.NXT 指向未接受但无法接受的数据字节的序列号

#### 接收窗口和发送窗口大小是一样的吗？

不是完全相等的，只能说约等于。\
因为滑动窗口不是一成不变的。如果接收方的应用进程处理速度非常快，接收窗口就会很快空出来，新的接受窗口大小，通过TCP头部的window字段告诉发送方，这个传输过程存在延时，所以不能保证发送方接收方窗口大小保持完全同步。

## 流量控制

发送方要考虑接收方的处理能力，不能一直无节制地发数据。为防止接收方接收缓存溢出，引入了流量控制机制。\
嘉禾客户端为接收方，服务端为发送方，接收窗口和发送窗口相同，都为200，嘉禾两个设备在整个传输过程中都保持相同的窗口大小，不受外界影响。流程描述：\
· 客户端向服务端发送请求数据报文\
· 服务端收到请求报文后，发送确认报文和80字节的数据，可用窗口变为120字节，SND.NXT的指针也向右偏移80字节\
· 客户端收到80字节数据后，接收窗口右移80字节(RCD.NXT右移80字节)接着发送确认报文给服务端\
· 服务端再次发送120字节的数据，可用窗口耗尽，为0，服务端无法再发送数据\
· 客户端收到120字节的数据，接收窗口右移120字节，接着发送确认报文给服务端\
· 服务端收到对80字节的确认报文后，SND.UNA向右移动80字节，可用窗口增大到80.\
· 服务端收到对120字节的 确认报文后，SND.NXT向右移动120字节，可用窗口增大到200\
· 服务端可以继续发送，于是发送160字节，SND.NXT向右移动160字节，可用窗口减少到40\
· 客户端收到160字节，接收窗口右移160字节，接着发送确认报文给服务端\
· 服务端收到对160字节的确认报文，SND.UNA右移160字节，可用窗口增长到200

注意，发送窗口和接收窗口所存储的字节都是放在操作系统内存缓冲区的，会被操作系统调整。当应用程序没有及时读取缓存，会出现的情况：\
· 客户端作为发送方，服务端作为接收方，发送窗口和接收窗口的初始大小均为360;\
· 服务端非常繁忙，当收到客户端的数据时，应用层不能及时读取数据。\
· 客户端发送140字节的数据，可用窗口变成220\
· 服务端收到140字节的数据，但是服务端非常忙，应用进程只读取了40字节，还有100字节占用着缓冲区，接收窗口缩到了260(360-100),发送确认信息时，将窗口大小告诉发送端\
· 客户端收到确认和窗口通告报文，发送窗口变为260\
· 客户端发送180字节数据，此时可用窗口减少到80\
· 服务端收到180字节数据，但应用程序没有读取任何数据，这180字节直接留在缓冲区，接收窗口收缩到80，发送确认信息\
· 客户端收到确认信息，窗口大小没有恢复，继续发送80字节的数据，发送窗口可用窗口变为0\
· 服务端收到 80 字节数据，但是应用程序依然没有读取任何数据，这 80 字节留在了缓冲区，于是接收窗口收缩到了 0，并在发送确认信息时，通过窗口大小给客户端\
· 客户端收到确认和窗口通告报文后，发送窗口减少为 0。

窗口大小为0时，会阻止发送方给接收方传输局，直到窗口变成非0，这叫窗口关闭。窗口关闭后一直等待窗口非0的通知，如果这个通知发过来，但在中途丢了，就会造成收发双发互相等待的死锁情况，为解决这个问题：TCP为每个连接设有一个持续定时器，只要TCP连接一方收到对方的零窗口通知，就启动持续计数器。
计时器超时就会发送窗口探测报文，对方在确认这个探测报文时，给出自己现在的接收窗口大小。如果接收窗口仍然是0，则重启计数器，不是0则死锁的局面可以打破。窗口探测的次数一般为3次，3次以后接收窗口还是0的话，可能会中止连接。

糊涂窗口综合征：明明只能发送几个字节的数据，还是坚持发送，相比于巨大的头部，开销很大

接收方措施：当接收窗口小于 min(MSS,1/2\*缓存)，接收端向发送端发送窗口为0通告\
发送方措施：Nagle算法

## 拥塞控制

网络出现拥堵，如果继续发送大量的数据包，可能会导致更大的延迟和丢包，重传加剧网络拥塞。避免发送方的数据填满整个网络。为调节发送方的数据发送量，引入了拥塞窗口。

此时发送窗口的值 = min(cwnd,rwnd), 即拥塞窗口和接收窗口的最小值

拥塞窗口变化的规则：\
· 只要网络中没有出现拥塞，拥塞窗口cwnd就会增大\
· 只要网络中出现了拥塞，拥塞窗口就减小

拥塞控制主要有四个算法：\
· 慢启动\
· 拥塞避免\
· 拥塞发生\
· 快恢复

### 慢启动

即一点一点地提高发送数据包的数量，一开始初始化cwnd=1, 当发送方每收到一个ACK，拥塞窗口大小就会加1.此时一次能发送2个。2个ACK确认到达后,cwnd变成了4.发包的个数呈指数型增长，什么时候停止？\
达到慢启动门限，切换算法。 cwnd<ssthresh，使用慢启动算法， cwnd>=ssthresh 使用拥塞避免算法

### 拥塞避免算法

每当收到一个ACK，cwnd增加 1/cwnd，将原本慢启动的指数增长变成了线性增长，增长速度更加缓慢，一直增长，网络慢慢就会进入拥塞状态，开始出现丢包现象，这是需要对丢失的数据包重传。触发了重传机制，也就进入了拥塞发生算法。

### 拥塞发生

· 采用超时重传： 慢启动门限值设为 ssthresh= cwnd/2 ,  cwnd重置为1. 于是重新开始慢启动，突然减少了数据流，会造成网络卡顿。\
· 采用快速重传： 三次重复ACK触发，慢启动门限设为 ssthresh=cwnd/2,  cwnd=cwnd/2, 进入快恢复算法

### 快恢复

快速重传和快速恢复算法一般同时使用，进入快速恢复之前，慢启动门限和拥塞窗口值已经被更新，进入快速恢复：\
· 拥塞窗口 cwnd =ssthresh+3\
· 重传丢失的数据包\
· 如果再收到重复的ACK，cwnd加1\
· 如果收到新数据的ACK，把cwnd设为第一步中的ssthresh的值，因为该ACK确认了新的数据，说明从duplicated ACK时的数据都已经收到，恢复过程结束，可以回到回复之前的状态了，即进入拥塞避免状态。
