## 1.数据库，数据库管理系统，数据库系统，数据库管理员的概念？

· 数据库：信息的集合。或者说是数据库管理系统管理的数据的集合。\
· 数据库管理系统：是一种操控和管理数据库的大型软件。\
· 数据库系统：由软件，数据库和数据管理员组成。\
· 数据库管理员：负责全面管理和控制数据库系统。

## 2.什么是元组，码，候选码，主码，外码，主属性，非主属性

· 元组：关系数据库中的概念，关系是一张表，表中的每行（即每条记录）就是一个元组，每列就是一个属性。二维表里元组也叫行。\
· 码：是一个属性，是能**唯一标识实体**的属性，对应表中的列。\
· 候选码：关系中的某一属性，或属性组能唯一表示一个元组，而其任何一个子集都无法标识，则称该属性组为一个候选码。如：学号可以区分每个学生，班级+姓名也可以区分
一个学生，但是单独的班级或学号不能区分一个学生，故学号是一个候选码，班级+姓名也是一个候选码。

· 主码：主码即主键。主键是从候选码中选出来的。一个实体集中只能有一个主码，但可以有多个候选码。\
· 外码：即外键。如果一个关系中的一个属性是另外一个关系中的主键，则这个属性为外键。\
· 主属性：候选码中出现过的属性称为主属性，如果主键是一个属性组，那么这个属性组中的属性都是主属性。\
· 非主属性：不包含在任何一个候选码中的属性为非主属性。

## 3.主键和外键的区别

主键：主键用于唯一标识一个元组，**不能有重复，不能为空，一个表只能有一个主键**。\
外键：外键用来和其他表建立联系，外键是另一个表的主键，外键可以有重复，可以为空值，一个表可以有多个外键。

## 4.数据库范式

### 1NF 第一范式

属性不能再被分割，该字段只能是一个值，不能再分为多个其他的字段了。第一范式（1NF）是所有关系型数据库的最基本要求。

### 2NF 第二范式

在1NF的基础之上，消除了非主属性对于码的部分函数依赖。第二范式在第一范式的基础上增加了一个列，这个列就是主键，非主属性都依赖主键。

### 3NF第三范式

消除了非主属性对于码的传递函数依赖。符合3NF要求的数据库，基本上解决了数据冗余过大，插入异常，删除异常，修改异常的问题。如关系R（学号，姓名，系名，系主任）
学号-->系名， 系名-->系主任，存在非主属性系主任对学号的传递函数依赖，不符合第三范式的要求。

解释：\
· 函数依赖：在一张表中，在属性X的值确定的情况下，必定能确定属性Y 的值，则可以说Y函数依赖于X，写作 X->Y\
· 部分函数依赖： 如果X->Y，并且存在X的一个真子集X0,使得 X0->Y, 则称Y对X部分函数依赖，如关系R(学号，身份证号，姓名),主属性组(学号，身份证号)，其任意一个真子集
都可以确定姓名，所以姓名这个属性部分函数依赖于(学号，身份证号)\
· 完全函数依赖：非主属性完全依赖于全部关键字，比如关系R（学号，班级，姓名），姓名必须由学号+班级的信息才能确定，因为不同班级有学号相同的。\
· 传递函数依赖：关系模式R(U)中，设X,Y,Z是U的不同属性子集，如果X确定Y,Y确定Z，且X不包含Y，Y不确定X,(XUY)∩Z=∅，则Z传递函数依赖X. **传递函数依赖会导致数据冗余，传递函数依赖的
Y和Z子集往往同属于某一个事物，因此可将其合并到一个表中。

## 5.存储过程

在业务比较复杂的情况下还是很方便的，存储过程写好并完成调试就可以稳定运行了，且比单纯的SQL语句执行要快，因为存储过程是预编译过的。但是其没有移植性，会消耗数据库资源。

## drop,delete ,truncate区别

### 用法不同

· drop： 丢弃数据， 语法： drop table 表名， 直接将表删除，删除表的时候用\
· truncate:清空数据，语法: truncate table 表名， 删除表中的数据，再插入数据的时候自增长id从1开始\
· delete:删除数据， delete from 表名 where 列名=值，删除某一列的数据，如果不加where子句和truncate table 表名类似

### 属于不同的数据库语言

truncate,delete属于数据定义语言（DDL）,操作后立即生效，不会放到回滚段中，不支持回滚。delete是数据库操作语言语句，会放到回滚段中，事务提交后才会生效

DML 语句和 DDL 语句区别：

·DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作\
·DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。

### 执行速度不同

一般来说:drop > truncate > delete。

## 6.数据库设计步骤

· 需求分析 : 分析用户的需求，包括数据、功能和性能需求。\
· 概念结构设计 : 主要采用E-R模型进行设计，包括画E-R图。\
· 逻辑结构设计 : 通过将E-R图转换成表，实现从E-R模型到关系模型的转换。\
· 物理结构设计 : 主要是为所设计的数据库选择合适的存储结构和存取路径。\
· 数据库实施 : 包括编程、测试和试运行\
· 数据库的运行和维护 : 系统的运行与数据库的日常维护。

## 7.数据库事务的特性

· 原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
· 一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
· 隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
· 持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

## 8.并发事务存在的问题

多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

· 脏读：当一个事务访问数据并修改时，由于这个修改还没有提交到数据库，此时如果另一个事务来访问数据，由于数据还没有被提交，所以另一个事务访问的数据为脏数据，可能会导致操作错误。\
· 丢失修改：第一个事务读取并修改数据，第二个事务也读取修改数据，这样第一个事务的修改结果就被丢失\
· 不可重复读：一个事务内多次读数据，如果两次读数据之间，另一个事务修改了数据，就会导致两次读的结果不同\
· 幻读：和不可重复读有点类似，两次读数据间另一个数据插入了一些数据，导致第二次读时发现一些原本 不存在的记录，似乎产生了幻觉。

不可重复读侧重于数据的修改，幻读侧重于数据的插入和删除。

## 9.事务隔离级别？ MySQL的默认隔离级别是什么

SQL标准定义了四个隔离标准：

· 读取未提交：最低的隔离级别，允许读取尚未提交的数据变更，可能导致脏读，幻读或不可重复读\
· 读取已提交：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读和不可重复读可能发生\
· 可重复读：对同一字段的多次读取结果都是一致的，除非数据是被事务本身修改，可以阻止脏读和不可重复读，但幻读可能发生\
· 可串行化：最高的隔离级别，**所有事务依次逐个执行**，这样事务之间就完全不可能产生干扰，可防止脏读，不可重复读，幻读。

MySQL,InnoDB默认支持的 隔离级别是 可重复读

## 10. 乐观锁与悲观锁的区别

### 悲观锁

总是假设最坏的情况，每次去取数据的时候总认为别人会修改，因此每次拿数据的时候都会上锁，其他线程想访问数据就被阻塞，直到资源被释放。

### 乐观锁

总是假设最好的情况，每次去拿数据的时候都会认为别人不会修改，所以不会上锁。但在更新的时候会判断一下在此期间别人有没有更新这个数据，可以使用CAS操作和版本号机制实现。**乐观锁适用于多读的应用类型，可以提高吞吐量，数据库提供的write_condition机制，都是提供的乐观锁**。

### 使用场景

乐观锁适用于写比较少的情况下，即冲突很少发生，可以省去了锁的开销，加大系统的吞吐量。多写的情况一般会经常发生冲突，就会导致上层应用会不断进行重试，
反倒降低了性能，故一般多写的情况下更适合悲观锁。

### 乐观锁的实现方式

· 版本号机制

在数据表中添加 数据版本号version字段,表示数据被修改的次数，当数据被修改时，version会加1. 线程A在更新数据时，在读取数据的同时也会读取version的值，提交更新时，若刚才读取到的version值为当前数据库中的version值相等才更新，否则重试更新操作，直到更新成功。

· CAS算法

即比较与交换，是有名的无锁算法。即不使用锁的情况下实现多线程间的变量同步，在没有线程被阻塞的情况下实现变量的同步。涉及到三个操作数：\
· 需要读写的内存值V\
· 进行比较的值A\
· 拟写入的新值B

当且仅当 V的值等于A时， CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作），一般情况下式一个自旋操作，即不断重试。

· 乐观锁的缺点

ABA问题：一个变量V初次读取的时候是A值，准备赋值的时候检查到它仍然是A值，但不能说明它没被修改过！可能中途修改为B值，然后又改回了A值。可以结合版本号机制来解决。

循环时间长开销大：因为它是自旋操作，不成功就一直循环执行直到成功，长时间不成功会给CPU带来很大的执行开销

只能保证一个共享变量的原子操作：CAS只对单个共享变量有效，当操作涉及多个共享变量时CAS无效。可以把多个变量放到一个对象里来操作。

## 11.MyISAM 和InnoDB的区别

· InnoDB支持事务，MyISAM不支持事务，这也是mysql选择InnoDB作为默认存储引擎的原因;\
· InnoDB支持外键，MyISAM不支持。如果表包含外键，并且存储引擎是InnoDB,转换成MyISAM会失败;\
· InnoDB使用聚集索引，MyISAM使用非聚集索引，聚簇索引的文件**存放在主键索引的叶子结点**，所以InnoDB必须要有主键，通过主键索引效率很高。辅助索引需要两次查询，先查询到主键，再查询到数据，所以主键不应该过大，因为主键太大，其他索引也都会很大。非聚集索引，数据文件是分离的，索引保存的是数据文件的**指针**，主键索引和辅助索引是独立的。\
· InnoDB不保存表的具体行数，执行 select count(\*) from table 时需要全表扫描. MyISAM使用了一个变量保存了整个表的行数，执行上述语句直接读出这个变量即可，速度很快。\
· InnoDB的最小粒度是**行级锁**，MyISAM最小粒度是表级锁。一个更新语句会锁住整张表，导致其他 查询和更新都会被阻塞。所以并发访问会受到很大限制。

那么如何选择存储引擎？

· 看是否要支持事务。如果要必须选择InnoDB，不需要可以考虑MyISAM；\
· 如果表中绝大多数都是读查询，可以考虑MyISAM，如果写也很频繁，就使用InnoDB.\
· 系统崩溃后，MyISAM恢复起来更困难\
· MySQL5.5以后的默认存储引擎是InnoDB

## 12.MySQL的主从复制

主从复制主要涉及三个线程： binlog线程， I/O线程， SQL线程。|
binlog线程：负责将主服务器上的数据更改写入二进制日志(Binary log)中
