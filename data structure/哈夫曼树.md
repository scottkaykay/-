## 哈夫曼树

路径：从一个节点到另一个节点间经过的所有节点，成为节点间的路径。

路径长度：从一个节点到另一个节点经过的边的数量（一定注意是边的数量！）

节点的带权路径长度：指树的根节点到该节点的路径**长度乘以该节点的权重**。

树的带权路径长度：所有叶子结点的带权路径长度之和，简称WPL.

哈夫曼树：在**叶子结点和权重确定**的情况下，**带权路径长度最小**的二叉树，也叫最优二叉树。

需要注意：同样的叶子结点所构成的哈夫曼树可能不止一棵。

如何构建？

给定叶子结点和权重： 2  3  7  9  18  25

i. 构建森林：

把每个节点看成独立的根节点，独自成为一棵树，就生成了森林。 引入辅助队列，按照权值从小到大存储所有的叶子结点。此时队列为：2 3 7 9 18 25

ii. 选择当前权值最小的两个节点（从辅助队列里面选，直接出队两个元素），生成新的父节点。父节点的权值是这两个节点的权值之和。此时父节点权值为5

  5
 /  \
2    3

iii. 从队列中删除刚才的那两个节点（出队），把新产生的父节点插入队列中，并保持队列的升序。此时队列为： 5 7 9 18 25

iv. 重复第二步操作，选择当前权值最小的两个节点，生成新的父节点：

       12
      /  \
     5    7
   /   \
  2     3

v. 重复第三步操作，删除选择的两个节点，插入新产生的父节点，此时队列为：  9 12 18 25

vi.重复第二步操作：

               21
             /   \
            9     12
                 /   \
                5    7
              /  \
             2    3

...
不断重复第2步和第3步，直到辅助队列只有一个节点：
              39
             /  \
            18  21
               /   \
              9     12
                  /   \
                  5    7
                /  \
                2   3
                
             64
            /  \
           25  39
              /  \
             18  21
                /   \
               9     12
                    /   \
                   5    7
                 /  \
                 2   3
  
 ## 实现
 
 实现时，可考虑优先队列来辅助，其可以保证插入元素时有序。
 复杂度分析：假设给定的叶子节点数位n,则主循环有n-1次，在循环内部，有优先队列的出队入队操作，每次的复杂度是logn,则总的复杂度为nlogn
 
 
 ##用途
 
 哈夫曼编码：一种高效的编码方式，用于信息压缩。
 
 计算机中的文件，底层都是用二进制来存储和传输的。将人类能看懂的信息转换为计算机中的二进制数据，这个过程称为编码。编码有很多方式，如ASCII编码，把一个字符表示成一个8位二进制数。
 它是一种等长编码。
 
 等长编码的优点：
 容易设计，方便读取。但如果编码结果过长会占用很多资源。
 
 哈夫曼编码是一种不定长编码，它有如下特性：
 
 · 任何一个字符的编码，都不是其他字符编码的前缀，不会产生歧义问题；
 · 信息编码的总长度最小。
 
 编码过程举例：
 
 假设信息为：A,B,C,D,E,F， 出现次数为： A:2  B:3  C:7  D:9  E:18  F:25
 
 把这6个字符看成是6个叶子节点，出现次数就是他们的权重，然后构建哈夫曼树，把节点的左分支视作0，右分支视作1.放在信息编码的场景下，叶子节点的权重对应字符
 出现的频次，节点的路径长度代表对应字符的编码长度。所有字符的路径长度之和最小，自然编码长度最小。
 
 
 
 
