# part2

## map 的实现机制

map是基于红黑树实现的。\
首先说明为什么用红黑树：红黑树是一种二叉搜索树，但在每个节点增加一个存储位表示节点的颜色，要么红要么黑。红黑树确保最长路径不会超过其他路径的2倍。因此，它是一种弱平衡树，相对于
平衡树来说，旋转次数少，对于插入删除操作较多的情况下，通常使用红黑树。插入最多2次，删除最多3次调整，复杂度为O(logN),N为节点个数，N个节点的红黑树树高最大为2log(N+1)

## list和vector的区别

vector是基于数组实现的，内存空间是连续的，支持下标访问。list是基于双向链表实现的，内存空间不连续，不支持下标访问，可使用指针访问。

## deque 实现

双端队列是一种支持向两端高效地插入数据，支持随机访问的容器。**双端队列的数据被放在一个个大小固定的数组中**，容器还要维护一个存放这些数组首地址的索引数组。
由于分段数组的大小是固定的，它们的首地址被连续存放在索引数组中，因此可以随机访问，但效率比vector低。向两端加入元素时，如果这一分段数组未满，则可以直接加入，
如果这一段的分段数组已满，只需创建新的分段数组，并把该分段数组地址加入到索引数组即可。不需要对元素进行移动，所以两端插入新元素的效率还是很高的。在两端删除的效率也很高。
但在中间插入或删除元素需要移动元素，导致效率下降。

## static作用

i. 修饰变量

· 修饰局部变量

编译器一般不对普通局部变量进行初始化，除非显式对其赋值。普通局部变量存储于进程栈空间，使用完毕后会立即释放。static修饰局部变量，将其变为静态局部变量，即使在声明时没有初始化，
编译器也会把它初始化为0.静态局部变量处于全局数据区，即使函数返回，它的值也不会改变。出了作用域不会被销毁，只是暂时无法访问。

· 修饰全局变量

使得该全局变量在定义之外的文件不可见。普通全局变量对整个工程可见，其他文件可通过extern外部声明后直接使用。其他文件不能再定义同名变量了。

ii. 修饰函数

在函数返回类型前加上 static, 函数称为静态函数，静态函数只能在声明它的文件中可见，其他文件不能引用该函数，不同文件可使用相同名称的静态函数，互不影响。
非静态函数可以在其他文件引用

iii. 修饰类成员，类方法

在类的数据成员声明前加上static，该数据成员就成了静态数据成员：\
· 静态数据成员存储在全局数据区，在定义时分配存储空间，所以**不能在类声明中定义**\
· 无论定义了多少个类的对象，静态数据成员的拷贝只有一个，且该类的所有对象可见。即任一对象都可以对静态数据成员进行操作。对于非静态数据成员，每个对象都有自己的一份拷贝。\
· 静态数据成员不属于任何对象，即使没有创建任何对象，也可以通过类名进行访问。\
· 和普通数据成员一样，静态数据成员遵从public,private,protected访问规则\
· 静态数据成员初始化方式： <数据类型><类名>::<静态数据成员名>=<值>\
· 类的静态数据成员的访问方式： <类对象名>.<静态数据成员名>     <类类型名>::<静态数据成员名>

和全局变量相比：\
· 静态数据成员没有进入程序的全局名字空间，不存在与程序中其他全局名字冲突的可能\
· 可以实现信息隐藏，可以设置访问权限为private,全局变量不可以

在类的成员函数的声明前加入static，成为静态成员函数。其属于整个类，而不是一个对象：\
· 静态成员函数没有this指针，无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其余的静态成员函数。\
· 出现在类体外的函数定义不能指定关键字static、
· 非静态成员函数可以任意访问静态成员函数和静态数据成员。

## delete 和 delete[] 的区别

一般使用new申请的内存，使用delete释放，使用new []申请的内存使用delete[]释放。对于基本数据类型，使用delete delete[] 效果是一样的，那是因为基本数据类型对象没有析构函数，new在分配内存时会记录分配的空间大小，delete就可以正确释放内存。
但是，如果使用new申请了一个对象数组，释放对象数组的内存，需要两步工作：第一步先释放最初申请的那部分空间，再调用对象析构函数完成清理，那么多个对象就需要多次调用析构函数。
如果此时使用delete，只会调用对象数组第一个对象的析构函数，导致后面的对象内存没有释放，造成内存泄露。

## 回调函数的作用

回调函数用来响应某些事件，是通过函数指针调用的函数。把如何实现的自由给了用户。

## 智能指针

主要包含： auto_ptr, unique_ptr, shared_ptr, weaked_ptr

对编译器而言，智能指针是一个栈对象，栈对象生命周期结束时，智能指针调用析构函数释放其管理的堆内存，所有智能指针都重载了->操作符，直接返回对象的引用。
每种智能指针都有reset方法，**不传入参数，智能指针会释放当前管理的内存。**如果传入对象，则会释放当前对象。

·auto_ptr:#include<memory>后即可使用，能够方便地管理单个堆内存对象，在auto_ptr 的赋值和拷贝过程中会发生控制权的转移，新的智能指针接管控制权，原来的智能指针指向空的内存空间。
release函数不会释放对象，只会归还所有权，应当使用reset()

· unique_ptr  可以像auto_ptr一样使用，但是 其独享控制权，明确拒绝向新的智能指针赋值的语句。\
· shared_ptr:通过引用计数的方式共享资源的所有权，多个shared_ptr可以管理同一个堆对象，当引用计数为0时，管理的资源也会被释放。

· weak_ptr 。不影响对象的生存周期，为了解决shared_ptr互相引用的问题。

## 什么是哈希表，应用场景是什么？

哈希表是以key-value形式存储数据的数据结构，通过某种映射关系（即哈希函数）将关键字和记录对应。可以实现随机访问，弥补了数组只能通过整数索引访问的缺陷。

应用场景：\
· 信息加密算法：把一些不同长度的信息转化为杂乱的128位的编码，这些编码值为hash值。hash找到了数据内容和数据存放地址之间的映射关系。\
· 查找：更加快速的查找方式，只要知道key值，就可以计算出数据存储的位置。\
· 处理海量数据：不论哈希表中有多少数据，查找，插入，删除都接近O(1)的时间复杂度，但是由于它是基于数组的，其一旦被填满，性能下降就会严重。

## 哈希冲突的解决方法

· 开放定址法：一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入：\
f(key)=(f(key)+d) MOD m

如关键字集合为{12,67,56,16,25,37,22,29,15,47,48,34},散列函数f(key)= key mod 12,计算前s个数{12,67,56,16,25}都没有冲突，直接存入：\
下标       0       1      2       3      4      5      6      7    8     9     10       11

关键字     12      25                    16                   67   56

key=37, f(37)=1, 此时与25所在的位置冲突，  f(37)=(f(37)+1) mod 12=2,  将37填在下标为2的位置

· 再哈希法：又叫双哈希法，有多个不同的hash函数，发生冲突时，使用第二个第三个等哈希函数计算地址，直到无冲突，不易发生聚集，但是增加了计算时间。\
· 链地址法：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的节点可以用单向链表连起来\
· 建立公共溢出区：将哈希表分为基本表和溢出表，凡是与基本表发生冲突的元素一律填入溢出表。

## 说说 extern 关键字

extern 可以置于变量或函数前，以表示**函数或变量的定义在别的文件中**，提示编译器遇到此变量或函数时在其他模块中寻找定义。extern也可用来进行链接指定。

它是一种外部声明关键字，字面意思就是在此处声明变量或函数，在别处定义。主要作用是扩大变量/函数 的作用域，使其他源文件和头文件可以复用同样的变量/函数，可以方便地划分代码。

还有一个作用是与"C"连用，构成extern C, 告知编译器要按照C的规则取翻译相应的函数名而不是C++的（C++支持函数重载）。

## strlen 和 sizeof

### sizeof

· sizeof是运算符，不是函数，strlen是函数。用来返回类型，对象所占的空间，在编译期间计算，所以不能用来返回动态分配的内存空间大小。\
· 数组：编译时分配的数组空间大小\
· 指针：存储该指针所用的空间大小（32位4字节，64位8字节）\
· 类型：该类型所占的空间大小\
· 对象：对象所占的空间大小\
· 函数：函数的返回类型所占的空间大小，函数的返回类型不能是void

### strlen

strlen是函数，在运行时才能计算。参数必须是字符型指针(char*),且必须是以'\0'结尾的。当数组名作为参数传入时，实际上数组就退化成指针了。\

### 总结

· sizeof操作符的结果类型为size_t,在头文件中typedef为unsigned int 类型。sizeof是操作符，strlen是函数，strlen必须以字符型指针做参数，sizeof的参数可以是类型，对象等等\
· 数组做sizeof的参数不退化，传递给strlen就退化为指针了\
· sizeof在编译期间计算，strlen只在运行时计算\
C++里参数传递数组永远都是传递指向数组首元素的指针，编译器不知道数组的大小 \
如果想在函数内知道数组的大小， 需要这样做： \
进入函数后用memcpy拷贝出来，长度由另一个形参传进去\
```C++
fun(unsiged char *p1, int len) 
{ 
unsigned char* buf = new unsigned char[len+1];
memcpy(buf, p1, len); 
} 
```

## strcpy,strcmp

```C++
char* mystrcpy(char* des,const char* src)//问题在于,src长度大于des，会出现越界，如果src中间有'\0'字符，最后无法完成整个src的复制，strncpy增加了一个参数n，表示复制n个字符，dest中必须保证以'\0'结束，否则直接访问des会出现栈溢出。可使用memset
{
assert(des!=NULL && src!=NULL);
char* address=des;
int i;
for(i=0;src[i]!='\0';i++)
    des[i]=src[i];
des[i]='\0';
return address;
}

char* mystrcat(char* des,const char* src)
{
    aseert(des!=NULL && src!=NULL);
    char* address=des;
    while(*des!='\0')
        des++;
    while(*des++=*src++) ;
    return address;
}

int strcmp(char* str1,const char* str2)
{
    int ret=0;
    while(!(ret=*(unsigned char)str1-*(unsigned char*)str2) && *str1)
    {
        str1++;
        str2++;
    }
    if(ret>0)
        return 1;
    else if(ret<0)
        return -1;
    else
        return 0;
}
```

## memcpy

memcpy函数用于把资源内存拷贝到目标内存，拷贝多少个，有一个size变量控制\
```c++
void* memcpy1(void* des,void* src,size_t size)
{
    if(des==NULL && src==NULL)
        return NULL;
    unsigned char* des1=(unsigned char*)des; //void* 强制类型转换
    unsigned char* src1=(unsigned char*)src;//void* 强制类型转换
    while(size-->0)
    {
        \*des1=\*src1;
        des1++;
        src1++;
    }
    return des;
}
```

## 使用sizeof求解类对象的大小因素

决定C++中对象大小的因素：\
· 所有非静态数据成员的大小\
· 数据成员的顺序；\
· 字节对齐或字节填充\
· 使用的编译器\
· 继承模式

对类做sizeof运算时，并不是简单地把各个数据成员大小相加，而是要考虑成员顺序不同，可能需要字节补齐。

## 如何比较两个struct相等

· 可以重载==操作符（bool operator==(const A&）)，逐一比较每个成员变量是否相等。\
· 不能用memcmp来判断，因为可能存在内存间隙，这里的值时随机的。

## epoll 和select/poll的区别

epoll是实现I/O多路复用的一种方法，有水平触发，边缘触发两种工作模式，区别在于两种模式返回的就绪状态的时间不同。\
· 水平触发：\
· 读：缓冲内容不为空返回读就绪\
· 写：缓冲区还不满返回写就绪\
· 边缘触发：\
· 读：缓冲区由不可读变为可读，新数据到达，缓冲区待读数据变多\
· 写：当有旧数据被发送走，即缓冲区的内容变少的时候

epoll之所以高效，是因为epoll将用户关心的文件描述符放到内核里的一个事件表中，而不是像select/epoll每次调用都需要重复传入文件描述符。当某个事件发生时，epoll无需遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入就绪队列的描述符集合即可。

## 指针和引用的区别

· 引用是变量的别名，对引用的操作就是对变量本身的操作，指针是一个变量，存储的内容是地址，指向内存的一个存储单元\
· 引用必须初始化（不能为空），指针可以为空，可在任何时候被初始化\
· 引用不占用内存，指针需要占用存储空间\
· C++引入的引用，C中无引用的概念\
· 可以有const指针，但没有const引用\
· 指针可以有多级，但引用只能是一级\
· 指针的值在初始化后可以改变，引用在初始化后就不会再改变了\
· sizeof引用得到的是所指向的变量(对象)的大小，而sizeof指针得到的是指针本身的大小

所谓的可以有const指针，但是没有const引用 是指： const指针：如 int* const p; 是可以有的，此时指针包含的地址是常量，不能修改，但可修改指针指向的数据。 注意与 const int* p；的区别，此时指针指向的数据为常量，不能修改，但可以修改指针包含的地址，即指针可以执向其他地方。 而所谓没有const引用，具体指没有int& const a这种形式，而const int& a是有的。前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变。

## ++i, i++

· ++i是先自增，再返回，i++是先返回后自增。 ++i的效率更高，++i不会生成临时对象，返回的是一个引用，可以作为左值使用，i++返回的是一个const int值，不能作为左值使用\

## 指针的指针使用场景

如果要在一个函数的参数中改变一个指针的值，就只能传这个指针的指针给这个函数，就合传引用交换两个数的值似的

## 如何不用中间变量交换两个变量的值

· 加减法,可交换整型和浮点型数值的变量，处理浮点型的数据可能出现精度上的损失

```C++
// a,b
a=a+b;
b=a-b;
a=a-b;
```
· 乘除法,用于整型变量和浮点型数值变量的交换

```C++
// a,b
a=a*b;
b=a/b;
a=a/b;
```
· 异或法,用于整型变量的交换

```C++
// a,b
a^=b;
b^=a;
a^=b;
```

## 如何选择排序算法？

· 数据量n比较小时（如n<=50），可以选择直接插入或直接选择排序\
· 如果初始状态基本有序，可选用直接插入，冒泡排序或随机快排\
· 如果n比较大，则选用时间复杂度为O(log(N))的排序算法，如快排，归并排序，堆排序，希尔排序等\
· n比较小，考虑稳定性，也可采用计数排序，基数排序，桶排序\
· 如果数据中重复的比较多，可使用归并排序和希尔排序

如2万名员工的年龄排序：\
· 要考虑员工的工号，即稳定性\
· 数量多\
· 重复较多

可使用归并排序
