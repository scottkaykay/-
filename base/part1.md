## C++基础知识（每部分30题）

### 1.拷贝构造函数相关

类中没有显式定义拷贝构造函数时，编译器会隐式定义一个缺省的拷贝构造函数，是一个inline,public的函数。形式为： 类名：：类名(const 类名 &) 
当自己定义了拷贝构造函数后，系统不再提供默认拷贝构造函数。

调用情况：\
· 将一个已存在的对象赋值给新对象；
· 对象作为函数的赋值参数，调用此函数生成新对象；
· 函数返回值为类对象，函数调用完返回时

赋值运算符重载函数是要把一个已存在的对象的各成员的值赋给另一个已存在的对象。\
注意，系统提供的缺省的拷贝构造函数只有简单的功能：即把一个对象所有成员的当前值赋值给新对象，只进行了浅拷贝。如果需要别的操作，则必须定义自己的拷贝构造函数。

如果对象存在动态成员，浅拷贝就会出现问题。比如成员变量中有指针，如果采用默认的拷贝构造函数，会使新对象的指针与原对象的指针指向同一内存，最后析构2次，
出现错误。解决方法是重写拷贝构造函数，对指针重新进行内存分配。

示例如下：

```C++
#include<iostream>
#include<assert.h>

using namespace std;
class Rect
{

    public:
        Rect()
        {
            p=new int(100);
        }
        Rect(const Rect& r)
        {
            width=r.width;
            height=r.height;
            p=new int(100);
            *p=*(r.p);
        }
        ~Rect()
        {
            assert(p!=NULL);
            delete p;
        }
private:
    int width;
    int height;
    int *p;
    };
int main()
{
    Rect rect1;
    Rect rect2(rect1);
    return 0;
}
```

#### 几个细节

i. 为什么拷贝构造函数必须是引用传递，不是值传递？\
避免引起递归引用。对象以值方式传递时，会生成一个临时对象，调用拷贝构造函数赋值，如果A的拷贝构造函数以值方式传递一个类A对象，会再次调用A的拷贝构造函数，
造成无限递归。

ii. 拷贝构造函数的作用\
复制对象，用对象的实例初始化另一个实例。

iii. 参数传递过程\
使用值传递：对于内置数据类型，直接拷贝赋值给形参，对于类类型，会调用拷贝构造函数进行初始化；
使用引用传递，无论是内置数据类型还是类类型，传递的都是地址值，属于简单类型，不会有拷贝构造函数的调用。

iv. 拷贝构造函数里能调用private成员变量么？\
当然可以。

v. 如何判断拷贝构造函数？\
第一个参数是： X&/ const X&/ volatile X&/const volatile X&

如果有其他参数，且其他参数有默认值，则该函数是拷贝构造函数。

vi. 一个类中可以存在多个拷贝构造函数吗？\
可以的。如： X(const X&); X(X&);  但是要注意，一个类中只有参数为X&的拷贝构造函数，是不能使用const X/volatile X的对象进行拷贝初始化的。

vii. 构造函数可以重载，但析构函数不行。为什么析构函数一般定义为虚函数？\
因为虚函数是实现多态的基础，通过基类的指针析构子类对象时，如果析构函数不是虚函数，那么只会调用基类的虚函数，子类的析构函数不会被调用，造成
内存无法释放。

### 2.makefile相关

make命令是GNU编译工具。它用于编译大量相互关联的源代码，可实现项目的工程化管理，提高开发效率。\
makefile文件告诉make源代码文件间的链接关系，依赖关系，从而准确地编译和链接成一个应用程序。
使用makfile定义规则，可以避免重复编译：\
· 如果工程从没有被编译过，所有的.c文件都要编译并链接。
· 如果有编译后的目标文件，但此工程的某些.c文件被改了，就只编译这些被修改的.c文件并链接目标程序；
· 如果有编译后的目标文件，但此工程的头文件改了，需要编译引用了这几个头文件的.c文件，并链接目标程序。

### 3. linux 下 GDB调试过程

i. 启动调试

gcc -g test.c -o mytest  //gcc编译，编译文件，生成mytest可执行程序。注意一定要加入调试信息：-g
gdb mytest.out  //进入gdb调试

ii. 显示当前代码： l (即list),一次只显示10行，如果想继续查看，继续使用该命令。

iii.在某行打断点： b 行号

iv. 开始运行程序： r

v.逐步执行 : s

vi. 重复上条命令： 直接enter

vii. 查看某个变量的变化： PRINT 变量名

viii. 查看变量类型 : WHATIS 变量名

ix. 看函数的堆栈： BT

x. 结束调试： FINISH

xi. 进入下一次调试： N

xii. 退出调试： Q

### 4. class和struct的区别

最大的区别在于struct的数据访问控制是public的，class的数据访问控制默认是private的。struct可以有成员函数，可以继承，可以实现多态！\
class可以作为定义模板的参数。
https://www.cnblogs.com/joean/p/4609279.html

### 5. new与malloc的区别

先拓展一点：内存分配函数还有 calloc, realloc.\
calloc在返回指向内存的指针之前将它初始化为0， calloc的参数包括所需元素数量和每个元素的字节数\
realloc函数用于修改一个已经分配的内存块的大小，可使一块内存扩大或缩小。如果扩大，原内存块保持不变，在内存尾部增加新的内存块，不进行初始化。\
如果缩小，原来的内存块从尾部进行删减。如果原内存无法扩充，则开辟一块新内存，复制原内存的内容，然后原内存失效。

来看new 与 malloc 的区别：\
· new/delete是关键字，需要编译器支持。malloc/free是标准库函数，需要头文件支持。\
· 使用new 进行内存分配不需要指定内存块大小，malloc需要显式地指出所需内存大小。\
· new操作成功时，返回对象类型的指针，类型严格与对象匹配，不需要进行强制类型转换。malloc内存分配成功返回的是void*,需要进行强制类型转换。\
· new分配内存失败会抛出bad_alloc异常，malloc内存分配失败会返回NULL.\
· new可以重载，malloc不允许重载\
· new从自由存储区上为对象动态分配内存，malloc从对上申请内存；\
· 对于自定义类型，new会先调用operate new函数申请足够的内存，然后调用类型的构造函数进行初始化，最后返回自定义类型指针。delete先调用析构函数，
然后调用operate delete函数释放内存，

### 6. define和const的区别

· define 是在编译的**预处理**阶段起作用，const实在编译运行时起作用；\
· define知识简单的字符串替换，没有类型检查。const有对应的数据类型，有类型检查。\
· define只是简单地替换，用多少次就换多少次，所以内存会有多个备份，const定义的只读变量在程序运行过程中只有一份备份。

const优点：

· const有对应的数据类型，可在编译时提供类型检查；\
· const在运行时只有一份备份，节省空间;\
· const常量可以被调试，宏定义常量不行。

### 7. const和static的用法

#### static 用法

·static 修饰局部变量，可以改变局部变量的生命周期，不改变作用域，其存储区域变为静态存储区。定义它的语句块结束时，其不会被销毁，直到程序结束。\
·static修饰全局变量，不改变其生命周期，改变其作用域，使其在声明它的文件之外是不可见的。其存储位置始终在静态存储区。普通全局变量只可定义一次，但可声明多次（外部链接），在某个文件使用时，必须先声明。\
·修饰类中的成员变量。用static修饰的数据成员会使其成为类的全局变量，被类的所有对象共享（包括子类对象）。**static成员必须在类外进行初始化，不能在构造函数里，因为它属于整个类，不属于某个对象，不接受this指针。**

注意点：\
· 不要在头文件中定义静态数据成员，可能会出现重复定义；
· 静态数据成员可以成为成员函数的**可选参数**，普通数据成员不行。
· 静态数据成员的类型可以是所属类的类型，普通数据成员智能声明为所属类类型的指针/引用。

用static修饰 的成员函数，被这个类的所有对象共享；无需创建实例就可以访问。在类外定义时不需要加static. 在静态成员函数的实现中，不能直接引用类中的非静态数据成员，可以引用静态数据成员，因为静态成员函数不含this指针。

**不可以同时用const和static修饰成员函数**：c++编译器在实现const成员函数时，为确保该函数不能修改类中的数据成员，会在函数中添加一个隐式的
const this*,当一个成员为static时，该函数是没有this指针的，这就冲突了。

#### const作用

限定变量不可修改；\
限定成员函数不可修改类中的任何数据成员。\
const char \*p  指针p指向内存的内容不可变
char* const p 指针p的指向不能变，即地址不能变

const成员变量不能在类定义处初始化，要在构造函数的初始化列表中初始化。\
const数据成员只在某个对象生存期内是常量，对整个类而言是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同，所以不能在类的声明中初始化const数据成员。如果想建立在整个类中都恒定的常量，可使用static const/枚举常量。static const在类外定义和初始化，定义时不用加static.

### 8.c++内存管理

#### 内存分配方式

· 栈：编译器分配的内存，用来存储函数的局部变量，函数调用结束后自动释放；\
· 堆：程序员使用malloc分配，free释放的内存\
· 自由存储区：使用new/delete完成内存的分配与释放\
· 全局/静态存储区：用来存放全局变量和static定义 的静态数据成员/函数\
· 常量存储区：用来存放常量，不允许修改

#### 堆和栈的区别

· 管理方式不同：栈主要由编译器分配和管理，堆主要由程序员进行分配和管理，使用malloc/free\
· 空间大小不同：堆一般可以分配较大的内存，而栈一般只有几M\
· 碎片问题：堆的内存在不断地被分配和释放过程中容易出现碎片化问题，而栈采用先入后出的机制，不会出现碎片；\
· 增长方向：堆是向着地址增大的方向增长的，栈是向着地址减小的方向增长\
· 分配方式：堆一般是动态分配的，栈有静态分配（alloc函数），也有动态分配，均由编译器执行\
· 分配效率：一般栈的分配效率更高，栈分配时由编译器和操作系统底层将临时变量放进寄存器，读写效率高。

#### 如何控制内存分配

重载new和delete

#### 内存分配可能出现的问题

· 内存分配不成功但使用了它，造成不可预测的错误。所以内存分配时，一定要检查是否出现异常\
· 内存分配成功，但没有初始化就使用，导致引用初值错误。一定要为动态内存赋初值\
· 内存分配成功并且已经初始化，但是操作越界；\
· 内存分配使用完后，忘记释放了，造成内存泄露\
· 使用了释放过的内存，使用free/delete 释放内存后，将指针置为NULL,防止产生野指针

#### 指针和数组间的对比

· 数组在静态存储区或栈上分配，数组名对应一块内存，在整个生命周期内，其地址和容量不变。但其内容可变。\
· 指针可以**随时指向任意类型的内存块**，更灵活但更危险。

#### 野指针

野指针不是NULL指针，是指向垃圾内存的指针。出现的原因：\
· 指针没有初始化\
· 内存使用完释放后，没有将指针置为NULL\
· 指针操作越界

### 9.描述一下面向对象的三大特性

·封装：封装是把过程和数据包围起来，隐藏实现细节，便于代码模块化。对象通过受保护的接口访问其他对象，即类可以把自己的数据和方法给可信的类或对象操作，对不可信的类或对象进行信息隐藏。

·继承：一般通过继承创建子类，使得子类具有父类的所有功能，并能在此基础上进行功能扩展。一般有实现继承和接口继承。\
实现继承：直接使用基类的属性和方法，无需额外编码；\
接口继承：只使用基类的属性和方法名，子类必须提供实现\
可视继承：指子窗体使用基窗体的外观和代码

· 多态：允许将子类类型的指针赋值给父类类型的指针。实现方式：重载，重写\
重载：在同一个类中的多个同名函数，其参数类型或参数个数不同，返回类型相同。对这些函数的调用，在编译期就确定（编译器根据参数表将它们视作不同的函数），所以是静态绑定了\
重写：也叫覆盖，存在于不同类中。子类中重新定义父类中的虚函数，父类指针根据赋给它的不同的子类指针，动态调用属于子类的方法。这样的函数调用在编译期是无法确定的。所以是动态绑定。每个类有一个虚表，每个类对象有一个虚指针。

如果有很多类，每个类都有一个虚表，而重写的方法又不多，每个表里面就会有大量的重复，造成空间利用率不高。MFC的消息映射机制不用虚函数，而是按照函数名称来查表，但由于要比较名称，有时候要遍历所有的继承结构，时间效率不是太高。

不能重载的运算符： .  *  ::  ?: sizeof

### 10. 虚基类

在继承的时候进行说明。举例：有一个类A,里面有个数据成员名为i。类B,类C继承了A, D同时继承了B和C，那么为保证D中的i与前面类中i的来源一致，使用虚继承。
这会使B,C继承的是同一个对象A,而不是2个A。

### 11. 为什么构造函数不能定义为虚函数

虚函数需要对应一个虚表指针，虚表指针是存储在对象的内存空间的，但是对象还没创建，就没有对象空间一说了。\
虚函数的作用在于通过父类的指针或引用调用子类的方法，构造函数是在创建对象时自动调用的，不可能通过父类指针或引用取调用。

### 12. 为什么只有引用和指针才能实现多态

引用和指针不会改变虚指针的指向，而对象值传递就会改变虚指针的指向，使得多态实现失败。

### 13. 静态绑定和动态绑定

· 静态类型：对象声明时采用的类型，在编译期已经确定\
· 动态类型：通常指一个指针或引用目前指向的类型，在运行期确定\
· 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；\
· 动态绑定：绑定的是动态类型，所对应的函数和属性依赖于对象的动态类型，发生在运行期。

只有虚函数才能动态绑定，非虚函数一般是静态绑定。\
总结静态绑定和动态绑定的区别：

· 静态绑定发生在编译期，动态绑定发生在运行期\
· 对象的动态类型可以改变，静态类型不可变\
· 要实现多态，必要要有动态绑定\
· 在继承体系中，只有虚函数使用动态绑定，其他的全部是静态绑定

### 14. 构造函数和析构函数调用虚函数可以吗

可以，但往往不能达到希望的效果。\
子类对象构造期间进入父类的构造函数，对象类型变为基类类型，而不是子类类型。同样地，进入父类的析构函数对象类型也会变成父类的，所以此时调用虚函数只会调用父类定义的虚函数，无法实现多态。

通俗解释：\
· 不要在构造函数中调用虚函数：父类对象会在子类之前构造，此时子类部分的数据成员还没有初始化，调用子类的虚函数是不安全的，所以c++不会进行动态联编。\
· 不要在析构函数中调用虚函数：析构时，子类对象在父类对象之前析构，在调用父类的析构函数时，子类对象数据成员已经销毁，此时再调用子类的虚函数已经没有意义了。

### 15. 深拷贝浅拷贝

主要区别还是在复制的时候有没有申请新内存。比如指针间的拷贝，如果是浅拷贝，则多个指针指向同一块内存，一旦内存释放，所有的指针都会失效。而深拷贝则先申请一块足够大的内存，再将数据复制过去，两者之间互不影响。

### 16. 对象复用和零拷贝

对象可以通过不同的设计模式实现复用，最常用的有继承和组合模式。 享元模式（对象池+状态外部化）

零拷贝：避免CPU将大量的时间花在数据拷贝上，专注解决更复杂的任务，提高系统资源利用的有效性。\
零拷贝技术常见于Linux中，例如内核空间到用户空间的拷贝，可采用零拷贝技术，利用mmap内存映射将内核空间的数据映射到用户空间上。

### 17 面向对象的设计原则

· 单一职责：一个类只负责一个功能区域中的相应职责\
· 开放封闭：一个软件实体应该对扩展开放，对修改关闭。即尽量在不修改源代码的情况下进行功能扩展。\
· 接口隔离：使用多个专门的接口，而不是单一的总接口，即客户端不应该以来那些它不需要的接口。\
· 里氏替换：子类可以扩展父类的功能，但是不能改变父类的功能。
· 依赖倒转：抽象不应该依赖于细节，细节应该依赖于抽象，即应该基于接口编程，而不是实现编程。\
· 合成复用：尽量使用对象组合，而不是继承来实现对象复用

### 18.遇到coredump应该怎么调

使能coredump，在操作系统出现异常时会生成一个文件，这个文件就是core,可使用gdb对这个文件进行分析和调试。

### 19.C++4种强制类型转换

· static_cast<目标数据类型>原数据类型\
· const_cast<目标数据类型> 原数据类型\
· reinterpret_cast<目标数据类型>原数据类型\
· dynamic_cast<目标数据类型>原数据类型

static_cast将源数据类型转换为目标数据类型，但**没有提供运行时类型检查来保证转换的安全性。**主要用法：\
i. 用于类层次结构中父类和子类之间指针或引用的转换，上行转换（把子类的指针或引用转换为父类表示是安全的），下行转换，由于没有动态类型检查，所以是不安全的\
ii. 用于基本数据类型间的转换，如把int转换为char，把char转换成enum,这种转换的安全性也要开发人员来保证;\
iii.把空指针转化为目标类型的空指针；\
iv.把任何类型的表达式转化为void类型

const_cast<>里边的内容必须是引用或指针，将变量的const属性去除，从而允许修改其值。但这种方式没有实质性的用处，尽量减少使用。\
reinterpret_cast: 改变指针或引用的类型；将指针或引用转化为一个足够长度的整型，或将整型转换为指针或引用类型。这是所有映射中最危险的，需要谨慎使用；\

dynamic_cast:\
· 其他三种都是在编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。\
· 不能用于内置的基本数据类型的强制转换；\
· dynamic_cast要求<>内的目标类型必须为指针或引用，dynamic_cast转换如果成功返回的是指向类的指针或引用，转换失败的话则返回nullptr。\
· 在类的转换过程中，在类层次间进行上行转换（子类指针转换为父类指针），dynamic_cast和static_cast效果是一样的，下行转换时，dynamic_cast提供类型检查，更安全。转换成功与否还需要看**指针指向的对象的实际类型与转换以后的对象类型一定要相同。**\
· 使用dynamic_cast进行转换的，基类中必须要有虚函数，否则编译无法通过。
