## 虚拟内存

https://blog.csdn.net/shellquery/article/details/100893040

操作系统完成由虚拟内存地址到真实内存地址或磁盘地址之间的映射工作，这样给用户提供的虚拟内存的地址空间就会非常大，用户程序中那些很久都用不到的内存空间可以被操作系统存在磁盘上，什么时候需要用了，再从磁盘中加载到真实内存。

虚拟内存结构：

内核：      操作系统代码和数据

               栈空间
               
               
               堆空间
               
               用户进程代码和数据（代码区，常量区，全局/静态存储区）
               
 ## Linux 虚拟内存 以x86架构的32位Linux系统为例
 
 Linux采用虚拟内存技术，让每个进程都有4GB的互不干涉的虚拟地址空间。进程初始化分配和操作都是基于这个虚拟地址，只有进程需要实际访问内存资源的时候，才会**建立虚拟地址和物理地址的映射，调入物理内存页。**
 
 ### 虚拟地址的好处：
 
 · 避免用户直接访问物理内存地址，防止一些破坏性操作\
 · 每个进程都被分配了4G的虚拟内存，用户程序可使用比实际物理内存更大的地址空间
 
 4G的进程虚拟地址空间分为两部分：用户空间和内核空间，其中用户空间占3G，内核空间占1G
 
 ### 物理地址
 
 不管是用户空间还是内核空间，使用的都是虚拟地址，当进程需要实际访问内存的时候，会由内核的 请求分页机制 产生缺页异常 调入物理内存页。把虚拟地址转换成内存的物理地址，涉及利用MMU内存管理单元，对虚拟地址
 分段和分页地址转换。如段页式内存管理地址转换：\
 逻辑地址  ------------------>   分段机制 ----------------------> 线性地址----------------------> 分页机制----------------------> 物理地址
 
 物理内存可分为3个管理区：\
 · DMA 内存区域。0~16MB的内存页框，直接映射到内核地址空间\
 · 普通内存区域： 16~896MB， 直接映射到内核的地址空间\
 · 高端内存区域，896MB以上的内存页框，不进行直接映射，可通过永久映射和临时映射进行这部分内存页框的访问
 
 ### 用户空间
 
 **用户进程**访问的是用户空间，每个进程都有自己独立的用户空间，虚拟地址范围为0x00000000~ 0xBFFFFFFF, 总容量3G，只有执行系统调用或硬件中断醋能访问内核空间
 
 用户空间按照访问属性一致的地址空间存放在一起的原则，划分成5个不同的内存区域，访问属性指的是“可读，可写，可执行”
 
 代码段：用来存放可执行文件的操作指令，可执行文件在内存中的镜像，要防止运行时被非法修改，所以是只读的。\
 数据段：存放可执行文件中已初始化的全局变量，即存放程序的静态变量和全局变量\
 BSS段：包含了程序中未初始化的全局变量，在内存中BSS段全部置零\
 堆：存放进程运行中动态分配的内存段，大小不固定，可动态扩张或缩减，当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上，当利用free等函数释放内存时，被释放的内存从堆中被剔除\
 栈：存放程序临时创建的局部变量，除此之外，函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的 返回值也会被存放回栈中，由于栈的先进后出特点，特别适合于保护现场恢复调用现场，，位置上，
 代码段和栈会被独立存放
 
 ### 内核空间
 
 虚拟地址范围为 0xC0000000~ 0XFFFFFFFF, 一共1G，可分为：\
 · 直接映射区： 从起始地址开始，最大896M的内核空间地址区间，即线性地址和分配的物理地址都是连续的，它们之间相差一个偏移量\
 · 高端内存线性地址空间：128M，又分为动态内存映射区，永久内存映射区，固定映射区
 
 · 动态内存映射区：该区域由内核函数vmalloc来分配，特点是：线性地址是连续的，物理地址不一定连续，vmalloc分配的线性地址所对应的物理页可能处于低端内存，也可能处于高端内存。
 
 · 永久内存映射区：该区域可访问高端内存，访问方法：使用 alloc_page (_GFP_HIGHMEM) 分配高端内存页或使用kmap函数将分配到的高端内存映射到该区域
 
 · 固定映射区：该区域和4G的顶端只有4K的隔离带，其每个地址项都服务于特定的用途
 
 ### 用户空间内存数据结构
 
 用户空间可划分为5个不同的内存区域：代码段，数据段，BSS段，堆，栈。将这些内存区域抽象成vm_area_struct的内存管理对象。vm_area_struct是描述进程地址空间的基本管理单元，一个进程地址空间往往往往需要多个vm_area_struct来描述，这些结构体之间
 使用链表或红黑树来组织。链表在需要遍历全部节点的时候用，红黑树用于在地址空间定位特定区域，内核为了内存区域上的各种不同操作都能获得高性能，所以同时使用了这两种数据结构。
 
### 内核空间的内存数据结构
 
 动态内存映射区：vmalloc分配的地址限于  vmalloc_start与vmalloc_end之间。每一块vmalloc分配的虚拟内存对应一个vm_struct结构体。不同内核空间虚拟地址之间有4K大小的防越界空闲区间隔区。与用户空间的虚拟地址特性一样，这些虚拟地址与物理内存没有简单的映射关系，
 必须通过内核页表才能转换为物理地址或物理页，它们有可能未被映射，当发生缺页时才真正分配物理页面。


## 物理内存管理

Linux系统中通过分段和 分页机制将物理内存划分为 4K 大小的内存页，物理内存的分配和回收都是基于内存页来进行。

问题：产生碎片问题

· 外部碎片： 当需要分配大块内存的时候，要用好几页组合起来才够，系统分配物理内存时会尽量分配连续的内存页面，频繁的分配与回收物理页导致大量的小块内存夹杂在已分配的物理页面之间，形成外部碎片\
· 内部碎片，当实际需要很小的内存的时候，也会分配至少是4K大小的页面，除去少量使用的内存，这一页剩下的内存全部浪费了。形成内部碎片

### 页面管理算法

伙伴分配算法：Linux内核引入了伙伴系统算法，把相同大小的页框块用链表串起来。把所有空闲页框分组为11种规格的块链表，规格大小分别为1,2,4,5,16,32,64,128,256,512,1024，即最大可以申请的页框大小为1024，为什么这样？因为任何正整数都可以由2^n的和组成

伙伴系统分配除去的内存是以页框为单位的，对于内核的很多场景都是分配小片内存，这会造成很多的内部碎片。引入slab分配器，按照使用对象的不同，把内存再划分为不同大小的空间，应用于内核对象缓存。
如task_struct,file_struct等需要重复使用的小型内核数据对象，都会有个slab缓存池，里面缓存了大量常用的已初始化的对象，每当申请这种类型的对象，就从缓存池的slab列表中分配一个出去，如果要释放，将其重新保存在该列表中，而不是直接返回给伙伴系统，避免内部碎片，大大提高了内存分配性能。

优点：slab内存管理基于内核小对象，不用每次都分配一页内存,避免内部碎片\
slab对内核中频繁创建和释放的小对象做缓存，重复利用一些相同的对象，减少内存分配次数。

### 内存分配

用户空间内存分配：malloc, 申请小于128KB的小内存时，使用sbrk/brk分配内存， 当申请大于128KB时，使用mmap函数申请内存，这三种函数都是系统调用开销，cpu在用户态和内核态频繁切换，非常影响性能。

采用内存池的实现方式，先申请一大块内存，然后将内存分成不同大小的内存块，然后用户申请内存时，直接从内存池选择一块相近的内存块分配出去。


                   直接映射区       kmalloc ----> slab分配器
内核程序-------->                                           -----------> 伙伴系统 --------> 物理内存空闲页框
                   动态内存映射区   vmalloc -----> 内核页表
