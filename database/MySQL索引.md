## MySQL索引

通过索引可以大幅提升检索效率。在关系型数据库中，索引是存储的表中的一个特定列的值数据结构。索引是在表的列上创建，它是一种数据结构。

查看索引：show index from xxx

PRIMARY KEY:   主键索引
Seq_in_index:  索引序号   Collation为"A"表示升序
idx_cid: 自建索引

## 索引采用的数据结构

· 哈希索引。可一次性定位，一次IO。查询效率高，但是只能完成等于，不等于，IN这样的查询，无法满足范围查询的要求，因为有序的数据经过哈希运算后不能保证
是原先的顺序了。不同数据的哈希运算结果还可能相同，当出现大量的相同哈希值时，还需要回到表中取遍历。

· BTree索引。时增删查改的复杂度都为O(logn)

是N叉树，树的高度会降低，查询更快。叶子节点，非叶子节点都能存储数据，且可以存储多个。通过中序遍历可访问树上所有节点。

局部性原理：软件设计要尽量遵循数据读取集中，使用到一个数据，大概率会使用其附近的数据。这样磁盘预读能充分提高磁盘IO效能。

目前用的比较多的索引是B+树。

改进点：
· 依然是N叉树，层级小，非叶子节点不再存储数据，数据只存储在同一层的叶子节点上，B+树从根节点到每个叶子结点的路径长度一样。
· 叶子之间增加了链表，获取所有节点不再需要中序遍历，使用链表的next节点就可以访问到。
· 范围查找方面，定位min与max后，中间的叶子结点就是结果集。
· 叶子结点存储实际记录行。记录行适用于大数据量存储。非叶子节点存储的是记录的KEY，这就使得B+树比B树能存储更多的索引。适合内存存储。

算一笔账： 一个节点大小为4KB, 每个KEY占8B，则一个节点可以存储500个KEY，为4KB。第二层为500*500=25W 500*4K=2M。第三层为25W*500=1.2亿
大约1G。B+树的索引占用很少的空间，却大大提升了查询效率，减少了磁盘读写。

## 索引基数Cardinality：
索引列的唯一值的个数。如果是复合索引，则是唯一组合的个数。如果唯一性比较小，则优化器会认为这个**索引对语句没有太大帮助**，从而不使用索引。
Cardinality越大，就意味着索引能排除越多的数据，执行更高效。

当有多个索引选择可用时，mysql会根据索引基数大的值来选择。为什么数据库都有主键？因为主键的值都不一样，索引基数大，查询效率高。
索引基数不会自动更新，需通过analyze来分析。
analyze local table ad_article

## 索引类型

### UNIQUE 唯一索引

被定义唯一索引的列，不允许出现重复数字，但可以为NULL。如果数据的重复会导致程序错误，可以使用唯一索引。

如果要发生变更，需要支持重复数据怎么办？

i. 自动替换为新的值： ONDUPLICATE KEY UPDATE xxx=VALUES(XXX)
ii. 忽略插入值： insert ignore into

### INDEX 普通索引

普通索引允许出现相同的索引内容，平时创建的索引通常就是普通索引。

### PRIMARY KEY 主键索引

不允许出现相同的值，不允许为空，一个表只能有一个主键索引，常见于ID字段

### FULLTEXT INDEX 全文索引

以上索引都是针对列的值发挥作用，但全文索引可针对值中的某个单词来作用，但只有MyISAM和英文支持，效率不高

## 索引创建

ALTER TABLE 适用于表创建完后再添加： ALTER TABLE 表名 ADD 索引类型  [索引名] (字段名)

CREATE INDEX 对表增加普通索引或UNIQUE索引： CREATE INDEX index_name ON table_name(column_list)
                                          CREATE UNIQUE INDEX index_name ON table_name(column_list)
                                          
也可在建表时添加：

CREATE TABLE mytable(
..//中间字段
PRIMARY KEY('id'),
UNIQUE KEY 'unique'('username')
KEY 'index1' ('nickname')
FULLTEXT KEY 'intro' ('intro')
)

一般在维度高的列建索引（维度高就是重复值少）；
对较小的数据列使用索引，使索引文件更小，内存中可装载更多的索引；
为较长的字符串使用前缀索引。

SELECT sname FROM stu WHERE age+10=30; --不会使用索引,因为有索引列参与了计算

SELECT sname FROM stu WHERE LEFT(`date`,4) <1990; -- 不会使用索引,因为使用了函数运算,原理与上面相同

SELECT * FROM table WHERE uname LIKE'前缀%' -- 走索引

SELECT * FROM table WHERE uname LIKE "%关键字%"-- 不走索引

SELECT * FROM table WHERE a=1 -- a列为char字符类型，用整数找不走索引，a='1'才走索引

SELECT * FROM table WHEREdname='xxx' or loc='xx' or deptno=45

-- 如果条件中有or,即使其中有条件带索引也不会使用。换言之,就是要求使用的所有字段,都必须建立索引,建议尽量避免使用or关键字

强制走索引：
select * from table where a=1 force index(PRI,my_index)

忽略某些索引：
select * from table where a=1 ignore index(PRI,my_index)

### 复合索引

复合索引中，索引第一位的column很重要，只要查询语句包含了复合索引的第一个条件，就会使用到该复合索引。所以在建索引的时候按照重要性从左往右建。

## 注意

索引不是越多越好，应该为那些查询操作频繁的列创建索引。
创建索引可使查询操作变得高效，但是会降低增加，删除，更新操作的速度，因为执行这些操作需要对索引进行重新排序或更新。

互联网应用中主要是查询比较多，在千万级的大表中，可不能随意创建索引，否则会出现锁表，业务崩溃等重大事故。

大表加索引方法： online-schema-change

## 索引的缺点

· 索引的创建和维护需要开销，且索引文件也是占用空间的，索引对于增删改的操作性能影响比较大：\
数据插入时，为了维护索引中字段的顺序，会先在索引中查找这个值，如果能找到，就把这个值插到后面空闲的地方，如果没有找到就把值加入到叶子结点，然后在分支节点中新增这个值和指向叶子结点的指针。这个过程中，如果某个页满了，还要申请一个空的页，把满的页拆分开，把一半的索引数据放到空闲页中，而且为了保证数据的一致性，还会给相关的索引页加上锁。delete操作和insert相反，删除一条数据时，会把这条数据涉及到的多个索引中的数据删除，开销要比insert小。update操作，只有update字段涉及到索引的时候，才需要维护索引，相对来说开销要小一些。

## SQL中#与$的区别

· #将传入的数据当做一个字符串，会对自动传入的数据加一个双引号，如 order by #user_id#,如果传入的值为id,则解析成的sql位order by "id"\
· $将传入的数据直接显示生成在sql中，如 order by $user_id$, 如果传入的值是id,则解析成的sql位order by id\
· #方式在很大程度上能防止sql注入，$无法防止sql注入，$一般用于传入数据库对象，例如传入表名\
· 一般能用#的就尽量别用$

#{}传入值时，sql解析时，参数是带引号的，${}传入值的时候参数是不带引号的
