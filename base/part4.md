## 并发编程三要素

· 原子性：一个操作或多个操作，要么全部执行，要么全部不执行。\
· 可见性：指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他线程可以立即看到修改的结果。实现可见性：synchronized 或者lock:保证同一时刻只有一个线程获取锁执行代码，
锁释放之前把最新的值刷新到主内存，实现可见性。\
· 有序性：程序的执行顺序按照代码的先后顺序来执行。

## 多线程的价值在何处？

· 可以发挥多核CPU的优势，充分利用CPU资源\
· 防止阻塞：从程序运行效率来看，单核CPU不仅不能发挥多线程的优势，还会因为多线程上下文切换而降低程序整体的效率。但还是要应用多线程，就是为了防止阻塞，如果有个线程在等待IO返回的数据，其他线程可以利用
CPU继续运行。

## 便于建模

假设有一个大的任务A,单线程编程，那么考虑的东西就会很大，容易出现纰漏。如果大任务分解成几个小任务，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。

## 创建线程的方式？

· 通过Thread类创建线程类\
· 通过Runnable接口创建线程类\
· 通过Callable和Future创建线程

对比：

· 使用 Runnable,Callable 接口创建多线程\
线程类只是实现了Runnable接口或Callable接口，还可以继承其他类，多个线程可以共享同一个目标对象，非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU,代码和数据分开，形成清晰的模型。
不好的一点是编程稍复杂，如果要访问当前线程，必须使用Thread,currentThread()方法。

· 使用继承Thread类的方式创建多线程\
编写简单，如果要访问当前线程，直接使用this即可获得当前线程，缺点是继承了Thread类，不能再继承别的类

· Runnable和Callable

Callable重写的方法是call(),  Runnable重写的方法是run() \
Callable的任务执行后可返回值，而Runnable是不能返回值的\
Call方法可以抛出异常，run方法不可以\
运行Callable任务可以拿到一个Future对象，表示异步计算的结果。

## 线程池

为什么要使用线程池？等到程序运行才创建线程，如果需要创建大量线程，则需要消耗很多资源，运行效率不高。
线程池实现：

优点：\
· 重用存在的线程，减少对象创建销毁的开销\
· 可有效地控制最大并发线程数，提高系统资源的利用率，同时避免过多资源的竞争\
· 提供定时执行，定期执行，单线程，并发数控制等功能

## Java里的volatile关键字

当一个共享变量被volatile修饰的时候，会保证修改的值被立即更新到主存，以保证可见性。

## 文件存储了10亿条销量数据，如何找出前10000大的数据？

·这个问题还是建立最小堆来解决。

思路：先拿10000个数建堆，然后依次添加剩下的元素，如果大于堆顶的数（10000个数中最小的），将这个数替换堆顶，并调整堆结构维持最小堆特性。这样遍历完后，堆中的10000个数就是所需的最大的10000个。建堆时间复杂度为O(NlogN),算法的时间复杂度为NMlogM, M为10000，N为10亿，即添加元素的外循环。优化：将10亿个数据分组存放，比如分别放在1000个文件中，这样处理就可以分别在每个文件10^6个数据中找到最大的10000个数，最后合并到一起找出最终的结果。

· 单机+单核+足够大内存  可使用排序方法\
· 单机+多核+足够大内存  分治+排序\
· 单机+单核+受限内存   需要将原数据文件切割成一个个的小文件，直至小文件小于内存大小，再放到内存中处理，使用排序的方法\
· 多机+受限内存 将数据分发到多台机器上，每台机器采用上一条的策略处理本地数据

## 海量数据中的重复问题

一般可以通过位图法实现。例如已知某个文件内包含一些电话号码，每个号码为=为8位数字，统计不同号码的个数。 8位数字能表示的最大十进制数为99999999，
每个数字对应于位图中的一个bit位，那么存储8位整数大约需要99Mb(1B=8bit,99/8=12.375MB)
