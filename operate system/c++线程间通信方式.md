## C++线程间通信

https://www.cnblogs.com/yhlboke-1992/p/9315263.html

### 全局变量

同一个进程里的线程共享地址空间和进程分配的资源，所以进程中定义的全局变量每个线程都可以访问，从而达到通信的目的。

### 临界区

临界区是一段独占对某些共享资源访问的代码，在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，在一个线程进入后，其他线程都会被挂起，并一直持续到临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，
并以此达到用原子方式操作共享资源的目的。

程序进入临界区后必须尽快离开，释放资源。如果线程进入临界区后挂了，就无法释放资源，但系统也无法得知。

临界区在使用时以 CRITICAL_SECTION 结构对象保护共享资源，并以 EnterCriticalSection() 和 LeaveCricticalSection()函数去标识和释放一个临界区，用到的CRITICAL_SECTION必须经过InitializeCriticalSection()的初始化后才能使用，必须保证所有线程中任何试图访问次共享资源的代码都在此临界区的保护之下。

### 互斥量

拥有互斥对象的线程才能访问共享资源，由于互斥对象只有一个，所有能保证同一时刻共享资源不会被多个线程访问。不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源的安全共享。
它和临界区的功能很相似，区别是互斥量mutex花费的时间比临界区多得多，但是mutex是核心对象(信号量，事件也是),可以跨进程使用，而且等待一个被锁住的互斥量可以设置差使时间，而临界区就必须一直等。互斥量的所有权
并不是属于产生它的线程，而是最后那个对此互斥量进行等待操作且未进行释放操作的线程。线程拥有mutex就像线程进入了临界区，一次只能有一个线程拥有muex，如果一个线程在返回前没有调用ReleaseMutex()释放互斥锁，那么这个互斥量会被丢弃，
能够知道一个互斥量被丢弃是互斥量特有的。

### 信号量

信号量是维护0到指定最大值之间的同步对象，信号量的值代表目前可用的资源数，调用wait锁定，资源数减1，调用ReleaseSemaphore资源数加1。信号量状态在其计数大于0时是有信号的，计数为0的时候是无信号的，信号量对象在控制上可以支持有限数量共享资源的访问。

特点：\
· 如果当前资源的数量大于0，则信号量有效\
· 如果当前资源的数量等于0，则信号量无效\
· 系统不允许当前资源的数量为负值\
· 当前资源数量决不能大于最大资源数量

### 事件

事件是最灵活的线程间同步方式，事件可以处于 **激发状态，或未激发状态**，根据状态变迁方式，可分为两类：\
手动重置事件：手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持在激发状态，直到程序重新把它设置为未激发状态\
自动重置事件：自动重事件被设置为激发状态后，会唤醒一个等待中的线程，然后自动恢复为未激发状态，所以用自动重置事件同步两个线程比较理想。

注意事项：\
· 如果要跨进程访问事件，必须对事件命名，在对事件命名的时候，要注意不要与命名空间中其他全局名字发生冲突\
· 事件是否要自动恢复\
· 事件初始状态的设置
