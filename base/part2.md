# part2

## map 的实现机制

map是基于红黑树实现的。\
首先说明为什么用红黑树：红黑树是一种二叉搜索树，但在每个节点增加一个存储位表示节点的颜色，要么红要么黑。红黑树确保最长路径不会超过其他路径的2倍。因此，它是一种弱平衡树，相对于
平衡树来说，旋转次数少，对于插入删除操作较多的情况下，通常使用红黑树。插入最多2次，删除最多3次调整，复杂度为O(logN)

## list和vector的区别

vector是基于数组实现的，内存空间是连续的，支持下标访问。list是基于双向链表实现的，内存空间不连续，不支持下标访问，可使用指针访问。

## deque 实现

双端队列是一种支持向两端高效地插入数据，支持随机访问的容器。**双端队列的数据被放在一个个大小固定的数组中**，容器还要维护一个存放这些数组首地址的索引数组。
由于分段数组的大小是固定的，它们的首地址被连续存放在索引数组中，因此可以随机访问，但效率比vector低。向两端加入元素时，如果这一分段数组未满，则可以直接加入，
如果这一段的分段数组已满，只需创建新的分段数组，并把该分段数组地址加入到索引数组即可。不需要对元素进行移动，所以两端插入新元素的效率还是很高的。在两端删除的效率也很高。
但在中间插入或删除元素需要移动元素，导致效率下降。

## static作用

i. 修饰变量

· 修饰局部变量

编译器一般不对普通局部变量进行初始化，除非显式对其赋值。普通局部变量存储于进程栈空间，使用完毕后会立即释放。static修饰局部变量，将其变为静态局部变量，即使在声明时没有初始化，
编译器也会把它初始化为0.静态局部变量处于全局数据区，即使函数返回，它的值也不会改变。出了作用域不会被销毁，只是暂时无法访问。

· 修饰全局变量

使得该全局变量在定义之外的文件不可见。普通全局变量对整个工程可见，其他文件可通过extern外部声明后直接使用。其他文件不能再定义同名变量了。

ii. 修饰函数

在函数返回类型前加上 static, 函数称为静态函数，静态函数只能在声明它的文件中可见，其他文件不能引用该函数，不同文件可使用相同名称的静态函数，互不影响。
非静态函数可以在其他文件引用

iii. 修饰类成员，类方法

在类的数据成员声明前加上static，该数据成员就成了静态数据成员：\
· 静态数据成员存储在全局数据区，在定义时分配存储空间，所以**不能在类声明中定义**\
· 无论定义了多少个类的对象，静态数据成员的拷贝只有一个，且该类的所有对象可见。即任一对象都可以对静态数据成员进行操作。对于非静态数据成员，每个对象都有自己的一份拷贝。\
· 静态数据成员不属于任何对象，即使没有创建任何对象，也可以通过类名进行访问。\
· 和普通数据成员一样，静态数据成员遵从public,private,protected访问规则\
· 静态数据成员初始化方式： <数据类型><类名>::<静态数据成员名>=<值>\
· 类的静态数据成员的访问方式： <类对象名>.<静态数据成员名>     <类类型名>::<静态数据成员名>

和全局变量相比：\
· 静态数据成员没有进入程序的全局名字空间，不存在与程序中其他全局名字冲突的可能\
· 可以实现信息隐藏，可以设置访问权限为private,全局变量不可以

在类的成员函数的声明前加入static，成为静态成员函数。其属于整个类，而不是一个对象：\
· 静态成员函数没有this指针，无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其余的静态成员函数。\
· 出现在类体外的函数定义不能指定关键字static、
· 非静态成员函数可以任意访问静态成员函数和静态数据成员。

## delete 和 delete[] 的区别

一般使用new申请的内存，使用delete释放，使用new []申请的内存使用delete[]释放。对于基本数据类型，使用delete delete[] 效果是一样的，那是因为基本数据类型对象没有析构函数，new在分配内存时会记录分配的空间大小，delete就可以正确释放内存。
但是，如果使用new申请了一个对象数组，释放对象数组的内存，需要两步工作：第一步先释放最初申请的那部分空间，再调用对象析构函数完成清理，那么多个对象就需要多次调用析构函数。
如果此时使用delete，只会调用对象数组第一个对象的析构函数，导致后面的对象内存没有释放，造成内存泄露。

## 回调函数的作用

回调函数用来响应某些事件，是通过函数指针调用的函数。把如何实现的自由给了用户。

## 智能指针

主要包含： auto_ptr, unique_ptr, shared_ptr, weaked_ptr

对编译器而言，智能指针是一个栈对象，栈对象生命周期结束时，智能指针调用析构函数释放其管理的堆内存，所有智能指针都重载了->操作符，直接返回对象的引用。
每种智能指针都有reset方法，**不传入参数，智能指针会释放当前管理的内存。**如果传入对象，则会释放当前对象。

·auto_ptr:#include<memory>后即可使用，能够方便地管理单个堆内存对象，在auto_ptr 的赋值和拷贝过程中会发生控制权的转移，新的智能指针接管控制权，原来的智能指针指向空的内存空间。
release函数不会释放对象，只会归还所有权，应当使用reset()

· unique_ptr  可以像auto_ptr一样使用，但是 其独享控制权，明确拒绝向新的智能指针赋值的语句。\
· shared_ptr:通过引用计数的方式共享资源的所有权，多个shared_ptr可以管理同一个堆对象，当引用计数为0时，管理的资源也会被释放。

· weak_ptr 。不影响对象的生存周期，为了解决shared_ptr互相引用的问题。
